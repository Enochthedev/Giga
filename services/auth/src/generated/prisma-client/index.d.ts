/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Role
 *
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>;
/**
 * Model Permission
 *
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>;
/**
 * Model UserRole
 *
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>;
/**
 * Model CustomerProfile
 *
 */
export type CustomerProfile =
  $Result.DefaultSelection<Prisma.$CustomerProfilePayload>;
/**
 * Model VendorProfile
 *
 */
export type VendorProfile =
  $Result.DefaultSelection<Prisma.$VendorProfilePayload>;
/**
 * Model DriverProfile
 *
 */
export type DriverProfile =
  $Result.DefaultSelection<Prisma.$DriverProfilePayload>;
/**
 * Model HostProfile
 *
 */
export type HostProfile = $Result.DefaultSelection<Prisma.$HostProfilePayload>;
/**
 * Model AdvertiserProfile
 *
 */
export type AdvertiserProfile =
  $Result.DefaultSelection<Prisma.$AdvertiserProfilePayload>;
/**
 * Model Address
 *
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>;
/**
 * Model RefreshToken
 *
 */
export type RefreshToken =
  $Result.DefaultSelection<Prisma.$RefreshTokenPayload>;
/**
 * Model EmailVerificationToken
 *
 */
export type EmailVerificationToken =
  $Result.DefaultSelection<Prisma.$EmailVerificationTokenPayload>;
/**
 * Model PasswordResetToken
 *
 */
export type PasswordResetToken =
  $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>;
/**
 * Model PhoneVerificationCode
 *
 */
export type PhoneVerificationCode =
  $Result.DefaultSelection<Prisma.$PhoneVerificationCodePayload>;
/**
 * Model AuditLog
 *
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const RoleName: {
    CUSTOMER: 'CUSTOMER';
    VENDOR: 'VENDOR';
    DRIVER: 'DRIVER';
    HOST: 'HOST';
    ADVERTISER: 'ADVERTISER';
    ADMIN: 'ADMIN';
  };

  export type RoleName = (typeof RoleName)[keyof typeof RoleName];

  export const SubscriptionTier: {
    BASIC: 'BASIC';
    PRO: 'PRO';
    ENTERPRISE: 'ENTERPRISE';
  };

  export type SubscriptionTier =
    (typeof SubscriptionTier)[keyof typeof SubscriptionTier];

  export const DriverTier: {
    BASIC: 'BASIC';
    PRO: 'PRO';
  };

  export type DriverTier = (typeof DriverTier)[keyof typeof DriverTier];

  export const HostTier: {
    BASIC: 'BASIC';
    PRO: 'PRO';
  };

  export type HostTier = (typeof HostTier)[keyof typeof HostTier];
}

export type RoleName = $Enums.RoleName;

export const RoleName: typeof $Enums.RoleName;

export type SubscriptionTier = $Enums.SubscriptionTier;

export const SubscriptionTier: typeof $Enums.SubscriptionTier;

export type DriverTier = $Enums.DriverTier;

export const DriverTier: typeof $Enums.DriverTier;

export type HostTier = $Enums.HostTier;

export const HostTier: typeof $Enums.HostTier;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    }
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   */
  get role(): Prisma.RoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Permissions
   * const permissions = await prisma.permission.findMany()
   * ```
   */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more UserRoles
   * const userRoles = await prisma.userRole.findMany()
   * ```
   */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.customerProfile`: Exposes CRUD operations for the **CustomerProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CustomerProfiles
   * const customerProfiles = await prisma.customerProfile.findMany()
   * ```
   */
  get customerProfile(): Prisma.CustomerProfileDelegate<ExtArgs>;

  /**
   * `prisma.vendorProfile`: Exposes CRUD operations for the **VendorProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more VendorProfiles
   * const vendorProfiles = await prisma.vendorProfile.findMany()
   * ```
   */
  get vendorProfile(): Prisma.VendorProfileDelegate<ExtArgs>;

  /**
   * `prisma.driverProfile`: Exposes CRUD operations for the **DriverProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more DriverProfiles
   * const driverProfiles = await prisma.driverProfile.findMany()
   * ```
   */
  get driverProfile(): Prisma.DriverProfileDelegate<ExtArgs>;

  /**
   * `prisma.hostProfile`: Exposes CRUD operations for the **HostProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more HostProfiles
   * const hostProfiles = await prisma.hostProfile.findMany()
   * ```
   */
  get hostProfile(): Prisma.HostProfileDelegate<ExtArgs>;

  /**
   * `prisma.advertiserProfile`: Exposes CRUD operations for the **AdvertiserProfile** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AdvertiserProfiles
   * const advertiserProfiles = await prisma.advertiserProfile.findMany()
   * ```
   */
  get advertiserProfile(): Prisma.AdvertiserProfileDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Addresses
   * const addresses = await prisma.address.findMany()
   * ```
   */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RefreshTokens
   * const refreshTokens = await prisma.refreshToken.findMany()
   * ```
   */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.emailVerificationToken`: Exposes CRUD operations for the **EmailVerificationToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more EmailVerificationTokens
   * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
   * ```
   */
  get emailVerificationToken(): Prisma.EmailVerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PasswordResetTokens
   * const passwordResetTokens = await prisma.passwordResetToken.findMany()
   * ```
   */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs>;

  /**
   * `prisma.phoneVerificationCode`: Exposes CRUD operations for the **PhoneVerificationCode** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PhoneVerificationCodes
   * const phoneVerificationCodes = await prisma.phoneVerificationCode.findMany()
   * ```
   */
  get phoneVerificationCode(): Prisma.PhoneVerificationCodeDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AuditLogs
   * const auditLogs = await prisma.auditLog.findMany()
   * ```
   */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;
  export import NotFoundError = runtime.NotFoundError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? K : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    Role: 'Role';
    Permission: 'Permission';
    UserRole: 'UserRole';
    CustomerProfile: 'CustomerProfile';
    VendorProfile: 'VendorProfile';
    DriverProfile: 'DriverProfile';
    HostProfile: 'HostProfile';
    AdvertiserProfile: 'AdvertiserProfile';
    Address: 'Address';
    RefreshToken: 'RefreshToken';
    EmailVerificationToken: 'EmailVerificationToken';
    PasswordResetToken: 'PasswordResetToken';
    PhoneVerificationCode: 'PhoneVerificationCode';
    AuditLog: 'AuditLog';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb
    extends $Utils.Fn<
      { extArgs: $Extensions.InternalArgs; clientOptions: PrismaClientOptions },
      $Utils.Record<string, any>
    > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      this['params']['clientOptions']
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    ClientOptions = {},
  > = {
    meta: {
      modelProps:
        | 'user'
        | 'role'
        | 'permission'
        | 'userRole'
        | 'customerProfile'
        | 'vendorProfile'
        | 'driverProfile'
        | 'hostProfile'
        | 'advertiserProfile'
        | 'address'
        | 'refreshToken'
        | 'emailVerificationToken'
        | 'passwordResetToken'
        | 'phoneVerificationCode'
        | 'auditLog';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>;
        fields: Prisma.RoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[];
          };
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RolePayload>;
          };
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRole>;
          };
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>;
            result: $Utils.Optional<RoleCountAggregateOutputType> | number;
          };
        };
      };
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>;
        fields: Prisma.PermissionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[];
          };
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[];
          };
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>;
          };
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePermission>;
          };
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PermissionGroupByOutputType>[];
          };
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PermissionCountAggregateOutputType>
              | number;
          };
        };
      };
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>;
        fields: Prisma.UserRoleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[];
          };
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[];
          };
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>;
          };
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUserRole>;
          };
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>;
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number;
          };
        };
      };
      CustomerProfile: {
        payload: Prisma.$CustomerProfilePayload<ExtArgs>;
        fields: Prisma.CustomerProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CustomerProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CustomerProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          findFirst: {
            args: Prisma.CustomerProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CustomerProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          findMany: {
            args: Prisma.CustomerProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>[];
          };
          create: {
            args: Prisma.CustomerProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          createMany: {
            args: Prisma.CustomerProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.CustomerProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>[];
          };
          delete: {
            args: Prisma.CustomerProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          update: {
            args: Prisma.CustomerProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          deleteMany: {
            args: Prisma.CustomerProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CustomerProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CustomerProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CustomerProfilePayload>;
          };
          aggregate: {
            args: Prisma.CustomerProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCustomerProfile>;
          };
          groupBy: {
            args: Prisma.CustomerProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CustomerProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.CustomerProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CustomerProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      VendorProfile: {
        payload: Prisma.$VendorProfilePayload<ExtArgs>;
        fields: Prisma.VendorProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.VendorProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.VendorProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          findFirst: {
            args: Prisma.VendorProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.VendorProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          findMany: {
            args: Prisma.VendorProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>[];
          };
          create: {
            args: Prisma.VendorProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          createMany: {
            args: Prisma.VendorProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.VendorProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>[];
          };
          delete: {
            args: Prisma.VendorProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          update: {
            args: Prisma.VendorProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          deleteMany: {
            args: Prisma.VendorProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.VendorProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.VendorProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$VendorProfilePayload>;
          };
          aggregate: {
            args: Prisma.VendorProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateVendorProfile>;
          };
          groupBy: {
            args: Prisma.VendorProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<VendorProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.VendorProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<VendorProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      DriverProfile: {
        payload: Prisma.$DriverProfilePayload<ExtArgs>;
        fields: Prisma.DriverProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.DriverProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.DriverProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          findFirst: {
            args: Prisma.DriverProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.DriverProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          findMany: {
            args: Prisma.DriverProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>[];
          };
          create: {
            args: Prisma.DriverProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          createMany: {
            args: Prisma.DriverProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.DriverProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>[];
          };
          delete: {
            args: Prisma.DriverProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          update: {
            args: Prisma.DriverProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          deleteMany: {
            args: Prisma.DriverProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.DriverProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.DriverProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$DriverProfilePayload>;
          };
          aggregate: {
            args: Prisma.DriverProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateDriverProfile>;
          };
          groupBy: {
            args: Prisma.DriverProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<DriverProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.DriverProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<DriverProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      HostProfile: {
        payload: Prisma.$HostProfilePayload<ExtArgs>;
        fields: Prisma.HostProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.HostProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.HostProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          findFirst: {
            args: Prisma.HostProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.HostProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          findMany: {
            args: Prisma.HostProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>[];
          };
          create: {
            args: Prisma.HostProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          createMany: {
            args: Prisma.HostProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.HostProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>[];
          };
          delete: {
            args: Prisma.HostProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          update: {
            args: Prisma.HostProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          deleteMany: {
            args: Prisma.HostProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.HostProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.HostProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$HostProfilePayload>;
          };
          aggregate: {
            args: Prisma.HostProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateHostProfile>;
          };
          groupBy: {
            args: Prisma.HostProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<HostProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.HostProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<HostProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      AdvertiserProfile: {
        payload: Prisma.$AdvertiserProfilePayload<ExtArgs>;
        fields: Prisma.AdvertiserProfileFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AdvertiserProfileFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AdvertiserProfileFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          findFirst: {
            args: Prisma.AdvertiserProfileFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AdvertiserProfileFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          findMany: {
            args: Prisma.AdvertiserProfileFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>[];
          };
          create: {
            args: Prisma.AdvertiserProfileCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          createMany: {
            args: Prisma.AdvertiserProfileCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AdvertiserProfileCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>[];
          };
          delete: {
            args: Prisma.AdvertiserProfileDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          update: {
            args: Prisma.AdvertiserProfileUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          deleteMany: {
            args: Prisma.AdvertiserProfileDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AdvertiserProfileUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AdvertiserProfileUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AdvertiserProfilePayload>;
          };
          aggregate: {
            args: Prisma.AdvertiserProfileAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAdvertiserProfile>;
          };
          groupBy: {
            args: Prisma.AdvertiserProfileGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AdvertiserProfileGroupByOutputType>[];
          };
          count: {
            args: Prisma.AdvertiserProfileCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AdvertiserProfileCountAggregateOutputType>
              | number;
          };
        };
      };
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>;
        fields: Prisma.AddressFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[];
          };
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>;
          };
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAddress>;
          };
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AddressGroupByOutputType>[];
          };
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>;
            result: $Utils.Optional<AddressCountAggregateOutputType> | number;
          };
        };
      };
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>;
        fields: Prisma.RefreshTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[];
          };
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[];
          };
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRefreshToken>;
          };
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<RefreshTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      EmailVerificationToken: {
        payload: Prisma.$EmailVerificationTokenPayload<ExtArgs>;
        fields: Prisma.EmailVerificationTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findFirst: {
            args: Prisma.EmailVerificationTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          findMany: {
            args: Prisma.EmailVerificationTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          create: {
            args: Prisma.EmailVerificationTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          createMany: {
            args: Prisma.EmailVerificationTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>[];
          };
          delete: {
            args: Prisma.EmailVerificationTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          update: {
            args: Prisma.EmailVerificationTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          deleteMany: {
            args: Prisma.EmailVerificationTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.EmailVerificationTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.EmailVerificationTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationTokenPayload>;
          };
          aggregate: {
            args: Prisma.EmailVerificationTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateEmailVerificationToken>;
          };
          groupBy: {
            args: Prisma.EmailVerificationTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<EmailVerificationTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.EmailVerificationTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<EmailVerificationTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>;
        fields: Prisma.PasswordResetTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[];
          };
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[];
          };
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>;
          };
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePasswordResetToken>;
          };
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[];
          };
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PasswordResetTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      PhoneVerificationCode: {
        payload: Prisma.$PhoneVerificationCodePayload<ExtArgs>;
        fields: Prisma.PhoneVerificationCodeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PhoneVerificationCodeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PhoneVerificationCodeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          findFirst: {
            args: Prisma.PhoneVerificationCodeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PhoneVerificationCodeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          findMany: {
            args: Prisma.PhoneVerificationCodeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>[];
          };
          create: {
            args: Prisma.PhoneVerificationCodeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          createMany: {
            args: Prisma.PhoneVerificationCodeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.PhoneVerificationCodeCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>[];
          };
          delete: {
            args: Prisma.PhoneVerificationCodeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          update: {
            args: Prisma.PhoneVerificationCodeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          deleteMany: {
            args: Prisma.PhoneVerificationCodeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PhoneVerificationCodeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PhoneVerificationCodeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PhoneVerificationCodePayload>;
          };
          aggregate: {
            args: Prisma.PhoneVerificationCodeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePhoneVerificationCode>;
          };
          groupBy: {
            args: Prisma.PhoneVerificationCodeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PhoneVerificationCodeGroupByOutputType>[];
          };
          count: {
            args: Prisma.PhoneVerificationCodeCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PhoneVerificationCodeCountAggregateOutputType>
              | number;
          };
        };
      };
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>;
        fields: Prisma.AuditLogFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[];
          };
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>;
          };
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAuditLog>;
          };
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogGroupByOutputType>[];
          };
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>;
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type GetLogType<T extends LogLevel | LogDefinition> =
    T extends LogDefinition
      ? T['emit'] extends 'event'
        ? T['level']
        : never
      : never;
  export type GetEvents<T extends any> =
    T extends Array<LogLevel | LogDefinition>
      ?
          | GetLogType<T[0]>
          | GetLogType<T[1]>
          | GetLogType<T[2]>
          | GetLogType<T[3]>
      : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName;
    action: PrismaAction;
    args: any;
    dataPath: string[];
    runInTransaction: boolean;
  };

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>
  ) => $Utils.JsPromise<T>;

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number;
    refreshTokens: number;
    emailVerificationTokens: number;
    passwordResetTokens: number;
    phoneVerificationCodes: number;
    adminAuditLogs: number;
    targetAuditLogs: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs;
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs;
    emailVerificationTokens?:
      | boolean
      | UserCountOutputTypeCountEmailVerificationTokensArgs;
    passwordResetTokens?:
      | boolean
      | UserCountOutputTypeCountPasswordResetTokensArgs;
    phoneVerificationCodes?:
      | boolean
      | UserCountOutputTypeCountPhoneVerificationCodesArgs;
    adminAuditLogs?: boolean | UserCountOutputTypeCountAdminAuditLogsArgs;
    targetAuditLogs?: boolean | UserCountOutputTypeCountTargetAuditLogsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserRoleWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RefreshTokenWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailVerificationTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EmailVerificationTokenWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PasswordResetTokenWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPhoneVerificationCodesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PhoneVerificationCodeWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTargetAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
  };

  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    permissions: number;
    users: number;
  };

  export type RoleCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs;
    users?: boolean | RoleCountOutputTypeCountUsersArgs;
  };

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PermissionWhereInput;
  };

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserRoleWhereInput;
  };

  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number;
  };

  export type PermissionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs;
  };

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
  };

  /**
   * Count Type CustomerProfileCountOutputType
   */

  export type CustomerProfileCountOutputType = {
    addresses: number;
  };

  export type CustomerProfileCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    addresses?: boolean | CustomerProfileCountOutputTypeCountAddressesArgs;
  };

  // Custom InputTypes
  /**
   * CustomerProfileCountOutputType without action
   */
  export type CustomerProfileCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfileCountOutputType
     */
    select?: CustomerProfileCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * CustomerProfileCountOutputType without action
   */
  export type CustomerProfileCountOutputTypeCountAddressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AddressWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    firstName: string | null;
    lastName: string | null;
    avatar: string | null;
    isEmailVerified: boolean | null;
    isPhoneVerified: boolean | null;
    isActive: boolean | null;
    lastLoginAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    activeRole: $Enums.RoleName | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    phone: string | null;
    passwordHash: string | null;
    firstName: string | null;
    lastName: string | null;
    avatar: string | null;
    isEmailVerified: boolean | null;
    isPhoneVerified: boolean | null;
    isActive: boolean | null;
    lastLoginAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    activeRole: $Enums.RoleName | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    phone: number;
    passwordHash: number;
    firstName: number;
    lastName: number;
    avatar: number;
    isEmailVerified: number;
    isPhoneVerified: number;
    isActive: number;
    lastLoginAt: number;
    createdAt: number;
    updatedAt: number;
    activeRole: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatar?: true;
    isEmailVerified?: true;
    isPhoneVerified?: true;
    isActive?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    activeRole?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatar?: true;
    isEmailVerified?: true;
    isPhoneVerified?: true;
    isActive?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    activeRole?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    passwordHash?: true;
    firstName?: true;
    lastName?: true;
    avatar?: true;
    isEmailVerified?: true;
    isPhoneVerified?: true;
    isActive?: true;
    lastLoginAt?: true;
    createdAt?: true;
    updatedAt?: true;
    activeRole?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    phone: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar: string | null;
    isEmailVerified: boolean;
    isPhoneVerified: boolean;
    isActive: boolean;
    lastLoginAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    activeRole: $Enums.RoleName;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      phone?: boolean;
      passwordHash?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      avatar?: boolean;
      isEmailVerified?: boolean;
      isPhoneVerified?: boolean;
      isActive?: boolean;
      lastLoginAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      activeRole?: boolean;
      roles?: boolean | User$rolesArgs<ExtArgs>;
      customerProfile?: boolean | User$customerProfileArgs<ExtArgs>;
      vendorProfile?: boolean | User$vendorProfileArgs<ExtArgs>;
      driverProfile?: boolean | User$driverProfileArgs<ExtArgs>;
      hostProfile?: boolean | User$hostProfileArgs<ExtArgs>;
      advertiserProfile?: boolean | User$advertiserProfileArgs<ExtArgs>;
      refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>;
      emailVerificationTokens?:
        | boolean
        | User$emailVerificationTokensArgs<ExtArgs>;
      passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>;
      phoneVerificationCodes?:
        | boolean
        | User$phoneVerificationCodesArgs<ExtArgs>;
      adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>;
      targetAuditLogs?: boolean | User$targetAuditLogsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      phone?: boolean;
      passwordHash?: boolean;
      firstName?: boolean;
      lastName?: boolean;
      avatar?: boolean;
      isEmailVerified?: boolean;
      isPhoneVerified?: boolean;
      isActive?: boolean;
      lastLoginAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      activeRole?: boolean;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    phone?: boolean;
    passwordHash?: boolean;
    firstName?: boolean;
    lastName?: boolean;
    avatar?: boolean;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    activeRole?: boolean;
  };

  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | User$rolesArgs<ExtArgs>;
    customerProfile?: boolean | User$customerProfileArgs<ExtArgs>;
    vendorProfile?: boolean | User$vendorProfileArgs<ExtArgs>;
    driverProfile?: boolean | User$driverProfileArgs<ExtArgs>;
    hostProfile?: boolean | User$hostProfileArgs<ExtArgs>;
    advertiserProfile?: boolean | User$advertiserProfileArgs<ExtArgs>;
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>;
    emailVerificationTokens?:
      | boolean
      | User$emailVerificationTokensArgs<ExtArgs>;
    passwordResetTokens?: boolean | User$passwordResetTokensArgs<ExtArgs>;
    phoneVerificationCodes?: boolean | User$phoneVerificationCodesArgs<ExtArgs>;
    adminAuditLogs?: boolean | User$adminAuditLogsArgs<ExtArgs>;
    targetAuditLogs?: boolean | User$targetAuditLogsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'User';
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[];
      customerProfile: Prisma.$CustomerProfilePayload<ExtArgs> | null;
      vendorProfile: Prisma.$VendorProfilePayload<ExtArgs> | null;
      driverProfile: Prisma.$DriverProfilePayload<ExtArgs> | null;
      hostProfile: Prisma.$HostProfilePayload<ExtArgs> | null;
      advertiserProfile: Prisma.$AdvertiserProfilePayload<ExtArgs> | null;
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[];
      emailVerificationTokens: Prisma.$EmailVerificationTokenPayload<ExtArgs>[];
      passwordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[];
      phoneVerificationCodes: Prisma.$PhoneVerificationCodePayload<ExtArgs>[];
      adminAuditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
      targetAuditLogs: Prisma.$AuditLogPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        phone: string | null;
        passwordHash: string;
        firstName: string;
        lastName: string;
        avatar: string | null;
        isEmailVerified: boolean;
        isPhoneVerified: boolean;
        isActive: boolean;
        lastLoginAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
        activeRole: $Enums.RoleName;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    roles<T extends User$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'findMany'> | Null
    >;
    customerProfile<T extends User$customerProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$customerProfileArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    vendorProfile<T extends User$vendorProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$vendorProfileArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    driverProfile<T extends User$driverProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$driverProfileArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    hostProfile<T extends User$hostProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$hostProfileArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    advertiserProfile<T extends User$advertiserProfileArgs<ExtArgs> = {}>(
      args?: Subset<T, User$advertiserProfileArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(
      args?: Subset<T, User$refreshTokensArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findMany'>
      | Null
    >;
    emailVerificationTokens<
      T extends User$emailVerificationTokensArgs<ExtArgs> = {},
    >(
      args?: Subset<T, User$emailVerificationTokensArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$EmailVerificationTokenPayload<ExtArgs>,
          T,
          'findMany'
        >
      | Null
    >;
    passwordResetTokens<T extends User$passwordResetTokensArgs<ExtArgs> = {}>(
      args?: Subset<T, User$passwordResetTokensArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PasswordResetTokenPayload<ExtArgs>,
          T,
          'findMany'
        >
      | Null
    >;
    phoneVerificationCodes<
      T extends User$phoneVerificationCodesArgs<ExtArgs> = {},
    >(
      args?: Subset<T, User$phoneVerificationCodesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PhoneVerificationCodePayload<ExtArgs>,
          T,
          'findMany'
        >
      | Null
    >;
    adminAuditLogs<T extends User$adminAuditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$adminAuditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    targetAuditLogs<T extends User$targetAuditLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$targetAuditLogsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly firstName: FieldRef<'User', 'String'>;
    readonly lastName: FieldRef<'User', 'String'>;
    readonly avatar: FieldRef<'User', 'String'>;
    readonly isEmailVerified: FieldRef<'User', 'Boolean'>;
    readonly isPhoneVerified: FieldRef<'User', 'Boolean'>;
    readonly isActive: FieldRef<'User', 'Boolean'>;
    readonly lastLoginAt: FieldRef<'User', 'DateTime'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly activeRole: FieldRef<'User', 'RoleName'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
  };

  /**
   * User.roles
   */
  export type User$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    where?: UserRoleWhereInput;
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    cursor?: UserRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * User.customerProfile
   */
  export type User$customerProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    where?: CustomerProfileWhereInput;
  };

  /**
   * User.vendorProfile
   */
  export type User$vendorProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    where?: VendorProfileWhereInput;
  };

  /**
   * User.driverProfile
   */
  export type User$driverProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    where?: DriverProfileWhereInput;
  };

  /**
   * User.hostProfile
   */
  export type User$hostProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    where?: HostProfileWhereInput;
  };

  /**
   * User.advertiserProfile
   */
  export type User$advertiserProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    where?: AdvertiserProfileWhereInput;
  };

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    where?: RefreshTokenWhereInput;
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    cursor?: RefreshTokenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * User.emailVerificationTokens
   */
  export type User$emailVerificationTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    where?: EmailVerificationTokenWhereInput;
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    cursor?: EmailVerificationTokenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * User.passwordResetTokens
   */
  export type User$passwordResetTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    where?: PasswordResetTokenWhereInput;
    orderBy?:
      | PasswordResetTokenOrderByWithRelationInput
      | PasswordResetTokenOrderByWithRelationInput[];
    cursor?: PasswordResetTokenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | PasswordResetTokenScalarFieldEnum
      | PasswordResetTokenScalarFieldEnum[];
  };

  /**
   * User.phoneVerificationCodes
   */
  export type User$phoneVerificationCodesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    where?: PhoneVerificationCodeWhereInput;
    orderBy?:
      | PhoneVerificationCodeOrderByWithRelationInput
      | PhoneVerificationCodeOrderByWithRelationInput[];
    cursor?: PhoneVerificationCodeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | PhoneVerificationCodeScalarFieldEnum
      | PhoneVerificationCodeScalarFieldEnum[];
  };

  /**
   * User.adminAuditLogs
   */
  export type User$adminAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User.targetAuditLogs
   */
  export type User$targetAuditLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    cursor?: AuditLogWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  export type RoleMinAggregateOutputType = {
    id: string | null;
    name: $Enums.RoleName | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleMaxAggregateOutputType = {
    id: string | null;
    name: $Enums.RoleName | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RoleCountAggregateOutputType = {
    id: number;
    name: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RoleMinAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleMaxAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RoleCountAggregateInputType = {
    id?: true;
    name?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Roles
     **/
    _count?: true | RoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RoleMaxAggregateInputType;
  };

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>;
  };

  export type RoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RoleWhereInput;
    orderBy?:
      | RoleOrderByWithAggregationInput
      | RoleOrderByWithAggregationInput[];
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum;
    having?: RoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RoleCountAggregateInputType | true;
    _min?: RoleMinAggregateInputType;
    _max?: RoleMaxAggregateInputType;
  };

  export type RoleGroupByOutputType = {
    id: string;
    name: $Enums.RoleName;
    createdAt: Date;
    updatedAt: Date;
    _count: RoleCountAggregateOutputType | null;
    _min: RoleMinAggregateOutputType | null;
    _max: RoleMaxAggregateOutputType | null;
  };

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> & {
        [P in keyof T & keyof RoleGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
          : GetScalarType<T[P], RoleGroupByOutputType[P]>;
      }
    >
  >;

  export type RoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      permissions?: boolean | Role$permissionsArgs<ExtArgs>;
      users?: boolean | Role$usersArgs<ExtArgs>;
      _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['role']
  >;

  export type RoleSelectScalar = {
    id?: boolean;
    name?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    permissions?: boolean | Role$permissionsArgs<ExtArgs>;
    users?: boolean | Role$usersArgs<ExtArgs>;
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type RoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $RolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Role';
    objects: {
      permissions: Prisma.$PermissionPayload<ExtArgs>[];
      users: Prisma.$UserRolePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: $Enums.RoleName;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['role']
    >;
    composites: {};
  };

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> =
    $Result.GetResult<Prisma.$RolePayload, S>;

  type RoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: RoleCountAggregateInputType | true;
  };

  export interface RoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Role'];
      meta: { name: 'Role' };
    };
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(
      args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUnique'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(
      args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     *
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     *
     */
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RoleCreateManyArgs>(
      args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'createManyAndReturn'>
    >;

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     *
     */
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>
    ): Prisma__RoleClient<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
     **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RoleAggregateArgs>(
      args: Subset<T, RoleAggregateArgs>
    ): Prisma.PrismaPromise<GetRoleAggregateType<T>>;

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Role model
     */
    readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$permissionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findMany'>
      | Null
    >;
    users<T extends Role$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Role$usersArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<'Role', 'String'>;
    readonly name: FieldRef<'Role', 'RoleName'>;
    readonly createdAt: FieldRef<'Role', 'DateTime'>;
    readonly updatedAt: FieldRef<'Role', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Roles.
     */
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Role create
   */
  export type RoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
  };

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Role update
   */
  export type RoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>;
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput;
  };

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput;
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>;
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>;
  };

  /**
   * Role delete
   */
  export type RoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput;
  };

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput;
  };

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    where?: PermissionWhereInput;
    orderBy?:
      | PermissionOrderByWithRelationInput
      | PermissionOrderByWithRelationInput[];
    cursor?: PermissionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Role.users
   */
  export type Role$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    where?: UserRoleWhereInput;
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    cursor?: UserRoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * Role without action
   */
  export type RoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
  };

  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null;
    _min: PermissionMinAggregateOutputType | null;
    _max: PermissionMaxAggregateOutputType | null;
  };

  export type PermissionMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    createdAt: Date | null;
  };

  export type PermissionMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    createdAt: Date | null;
  };

  export type PermissionCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    createdAt: number;
    _all: number;
  };

  export type PermissionMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    createdAt?: true;
  };

  export type PermissionMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    createdAt?: true;
  };

  export type PermissionCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    createdAt?: true;
    _all?: true;
  };

  export type PermissionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?:
      | PermissionOrderByWithRelationInput
      | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Permissions
     **/
    _count?: true | PermissionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PermissionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PermissionMaxAggregateInputType;
  };

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
    [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>;
  };

  export type PermissionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PermissionWhereInput;
    orderBy?:
      | PermissionOrderByWithAggregationInput
      | PermissionOrderByWithAggregationInput[];
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum;
    having?: PermissionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PermissionCountAggregateInputType | true;
    _min?: PermissionMinAggregateInputType;
    _max?: PermissionMaxAggregateInputType;
  };

  export type PermissionGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    createdAt: Date;
    _count: PermissionCountAggregateOutputType | null;
    _min: PermissionMinAggregateOutputType | null;
    _max: PermissionMaxAggregateOutputType | null;
  };

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PermissionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PermissionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>;
        }
      >
    >;

  export type PermissionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      createdAt?: boolean;
      roles?: boolean | Permission$rolesArgs<ExtArgs>;
      _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['permission']
  >;

  export type PermissionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      createdAt?: boolean;
    },
    ExtArgs['result']['permission']
  >;

  export type PermissionSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    createdAt?: boolean;
  };

  export type PermissionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>;
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type PermissionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $PermissionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Permission';
    objects: {
      roles: Prisma.$RolePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['permission']
    >;
    composites: {};
  };

  type PermissionGetPayload<
    S extends boolean | null | undefined | PermissionDefaultArgs,
  > = $Result.GetResult<Prisma.$PermissionPayload, S>;

  type PermissionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: PermissionCountAggregateInputType | true;
  };

  export interface PermissionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Permission'];
      meta: { name: 'Permission' };
    };
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(
      args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(
      args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     *
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PermissionFindManyArgs>(
      args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     *
     */
    create<T extends PermissionCreateArgs>(
      args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PermissionCreateManyArgs>(
      args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Permissions and only return the `id`
     * const permissionWithIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PermissionPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     *
     */
    delete<T extends PermissionDeleteArgs>(
      args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PermissionUpdateArgs>(
      args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PermissionDeleteManyArgs>(
      args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PermissionUpdateManyArgs>(
      args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(
      args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>
    ): Prisma__PermissionClient<
      $Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
     **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PermissionAggregateArgs>(
      args: Subset<T, PermissionAggregateArgs>
    ): Prisma.PrismaPromise<GetPermissionAggregateType<T>>;

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPermissionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Permission model
     */
    readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(
      args?: Subset<T, Permission$rolesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<'Permission', 'String'>;
    readonly name: FieldRef<'Permission', 'String'>;
    readonly description: FieldRef<'Permission', 'String'>;
    readonly createdAt: FieldRef<'Permission', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?:
      | PermissionOrderByWithRelationInput
      | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?:
      | PermissionOrderByWithRelationInput
      | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Permissions to fetch.
     */
    orderBy?:
      | PermissionOrderByWithRelationInput
      | PermissionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Permissions.
     */
    skip?: number;
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[];
  };

  /**
   * Permission create
   */
  export type PermissionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>;
  };

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>;
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<
      PermissionUpdateManyMutationInput,
      PermissionUncheckedUpdateManyInput
    >;
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput;
  };

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput;
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>;
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>;
  };

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput;
  };

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput;
  };

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null;
    where?: RoleWhereInput;
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[];
    cursor?: RoleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[];
  };

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null;
  };

  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  export type UserRoleMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    roleId: string | null;
    assignedAt: Date | null;
  };

  export type UserRoleMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    roleId: string | null;
    assignedAt: Date | null;
  };

  export type UserRoleCountAggregateOutputType = {
    id: number;
    userId: number;
    roleId: number;
    assignedAt: number;
    _all: number;
  };

  export type UserRoleMinAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
    assignedAt?: true;
  };

  export type UserRoleMaxAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
    assignedAt?: true;
  };

  export type UserRoleCountAggregateInputType = {
    id?: true;
    userId?: true;
    roleId?: true;
    assignedAt?: true;
    _all?: true;
  };

  export type UserRoleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned UserRoles
     **/
    _count?: true | UserRoleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserRoleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserRoleMaxAggregateInputType;
  };

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
    [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>;
  };

  export type UserRoleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserRoleWhereInput;
    orderBy?:
      | UserRoleOrderByWithAggregationInput
      | UserRoleOrderByWithAggregationInput[];
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum;
    having?: UserRoleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserRoleCountAggregateInputType | true;
    _min?: UserRoleMinAggregateInputType;
    _max?: UserRoleMaxAggregateInputType;
  };

  export type UserRoleGroupByOutputType = {
    id: string;
    userId: string;
    roleId: string;
    assignedAt: Date;
    _count: UserRoleCountAggregateOutputType | null;
    _min: UserRoleMinAggregateOutputType | null;
    _max: UserRoleMaxAggregateOutputType | null;
  };

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<UserRoleGroupByOutputType, T['by']> & {
          [P in keyof T & keyof UserRoleGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>;
        }
      >
    >;

  export type UserRoleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      roleId?: boolean;
      assignedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      role?: boolean | RoleDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userRole']
  >;

  export type UserRoleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      roleId?: boolean;
      assignedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      role?: boolean | RoleDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['userRole']
  >;

  export type UserRoleSelectScalar = {
    id?: boolean;
    userId?: boolean;
    roleId?: boolean;
    assignedAt?: boolean;
  };

  export type UserRoleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };
  export type UserRoleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    role?: boolean | RoleDefaultArgs<ExtArgs>;
  };

  export type $UserRolePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'UserRole';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      role: Prisma.$RolePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        roleId: string;
        assignedAt: Date;
      },
      ExtArgs['result']['userRole']
    >;
    composites: {};
  };

  type UserRoleGetPayload<
    S extends boolean | null | undefined | UserRoleDefaultArgs,
  > = $Result.GetResult<Prisma.$UserRolePayload, S>;

  type UserRoleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: UserRoleCountAggregateInputType | true;
  };

  export interface UserRoleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['UserRole'];
      meta: { name: 'UserRole' };
    };
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(
      args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<
        Prisma.$UserRolePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<
        Prisma.$UserRolePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(
      args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<
        Prisma.$UserRolePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<
        Prisma.$UserRolePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     *
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserRoleFindManyArgs>(
      args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     *
     */
    create<T extends UserRoleCreateArgs>(
      args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserRoleCreateManyArgs>(
      args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many UserRoles and only return the `id`
     * const userRoleWithIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserRolePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     *
     */
    delete<T extends UserRoleDeleteArgs>(
      args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserRoleUpdateArgs>(
      args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(
      args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserRoleUpdateManyArgs>(
      args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(
      args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>
    ): Prisma__UserRoleClient<
      $Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
     **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserRoleAggregateArgs>(
      args: Subset<T, UserRoleAggregateArgs>
    ): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>;

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserRoleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the UserRole model
     */
    readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, RoleDefaultArgs<ExtArgs>>
    ): Prisma__RoleClient<
      | $Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly id: FieldRef<'UserRole', 'String'>;
    readonly userId: FieldRef<'UserRole', 'String'>;
    readonly roleId: FieldRef<'UserRole', 'String'>;
    readonly assignedAt: FieldRef<'UserRole', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of UserRoles to fetch.
     */
    orderBy?:
      | UserRoleOrderByWithRelationInput
      | UserRoleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` UserRoles.
     */
    skip?: number;
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[];
  };

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>;
  };

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>;
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<
      UserRoleUpdateManyMutationInput,
      UserRoleUncheckedUpdateManyInput
    >;
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput;
  };

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput;
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>;
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>;
  };

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput;
  };

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput;
  };

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null;
  };

  /**
   * Model CustomerProfile
   */

  export type AggregateCustomerProfile = {
    _count: CustomerProfileCountAggregateOutputType | null;
    _min: CustomerProfileMinAggregateOutputType | null;
    _max: CustomerProfileMaxAggregateOutputType | null;
  };

  export type CustomerProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CustomerProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CustomerProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    preferences: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CustomerProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CustomerProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CustomerProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    preferences?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CustomerProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CustomerProfile to aggregate.
     */
    where?: CustomerProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?:
      | CustomerProfileOrderByWithRelationInput
      | CustomerProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CustomerProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CustomerProfiles
     **/
    _count?: true | CustomerProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CustomerProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CustomerProfileMaxAggregateInputType;
  };

  export type GetCustomerProfileAggregateType<
    T extends CustomerProfileAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateCustomerProfile]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProfile[P]>
      : GetScalarType<T[P], AggregateCustomerProfile[P]>;
  };

  export type CustomerProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CustomerProfileWhereInput;
    orderBy?:
      | CustomerProfileOrderByWithAggregationInput
      | CustomerProfileOrderByWithAggregationInput[];
    by: CustomerProfileScalarFieldEnum[] | CustomerProfileScalarFieldEnum;
    having?: CustomerProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CustomerProfileCountAggregateInputType | true;
    _min?: CustomerProfileMinAggregateInputType;
    _max?: CustomerProfileMaxAggregateInputType;
  };

  export type CustomerProfileGroupByOutputType = {
    id: string;
    userId: string;
    preferences: JsonValue | null;
    createdAt: Date;
    updatedAt: Date;
    _count: CustomerProfileCountAggregateOutputType | null;
    _min: CustomerProfileMinAggregateOutputType | null;
    _max: CustomerProfileMaxAggregateOutputType | null;
  };

  type GetCustomerProfileGroupByPayload<T extends CustomerProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<CustomerProfileGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof CustomerProfileGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProfileGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type CustomerProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      preferences?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      addresses?: boolean | CustomerProfile$addressesArgs<ExtArgs>;
      _count?: boolean | CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['customerProfile']
  >;

  export type CustomerProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      preferences?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['customerProfile']
  >;

  export type CustomerProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    preferences?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CustomerProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    addresses?: boolean | CustomerProfile$addressesArgs<ExtArgs>;
    _count?: boolean | CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type CustomerProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CustomerProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'CustomerProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      addresses: Prisma.$AddressPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        preferences: Prisma.JsonValue | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['customerProfile']
    >;
    composites: {};
  };

  type CustomerProfileGetPayload<
    S extends boolean | null | undefined | CustomerProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$CustomerProfilePayload, S>;

  type CustomerProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<CustomerProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: CustomerProfileCountAggregateInputType | true;
  };

  export interface CustomerProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CustomerProfile'];
      meta: { name: 'CustomerProfile' };
    };
    /**
     * Find zero or one CustomerProfile that matches the filter.
     * @param {CustomerProfileFindUniqueArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerProfileFindUniqueArgs>(
      args: SelectSubset<T, CustomerProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one CustomerProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerProfileFindUniqueOrThrowArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CustomerProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first CustomerProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindFirstArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerProfileFindFirstArgs>(
      args?: SelectSubset<T, CustomerProfileFindFirstArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first CustomerProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindFirstOrThrowArgs} args - Arguments to find a CustomerProfile
     * @example
     * // Get one CustomerProfile
     * const customerProfile = await prisma.customerProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more CustomerProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProfiles
     * const customerProfiles = await prisma.customerProfile.findMany()
     *
     * // Get first 10 CustomerProfiles
     * const customerProfiles = await prisma.customerProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const customerProfileWithIdOnly = await prisma.customerProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CustomerProfileFindManyArgs>(
      args?: SelectSubset<T, CustomerProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a CustomerProfile.
     * @param {CustomerProfileCreateArgs} args - Arguments to create a CustomerProfile.
     * @example
     * // Create one CustomerProfile
     * const CustomerProfile = await prisma.customerProfile.create({
     *   data: {
     *     // ... data to create a CustomerProfile
     *   }
     * })
     *
     */
    create<T extends CustomerProfileCreateArgs>(
      args: SelectSubset<T, CustomerProfileCreateArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many CustomerProfiles.
     * @param {CustomerProfileCreateManyArgs} args - Arguments to create many CustomerProfiles.
     * @example
     * // Create many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CustomerProfileCreateManyArgs>(
      args?: SelectSubset<T, CustomerProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many CustomerProfiles and returns the data saved in the database.
     * @param {CustomerProfileCreateManyAndReturnArgs} args - Arguments to create many CustomerProfiles.
     * @example
     * // Create many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CustomerProfiles and only return the `id`
     * const customerProfileWithIdOnly = await prisma.customerProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CustomerProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, CustomerProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CustomerProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a CustomerProfile.
     * @param {CustomerProfileDeleteArgs} args - Arguments to delete one CustomerProfile.
     * @example
     * // Delete one CustomerProfile
     * const CustomerProfile = await prisma.customerProfile.delete({
     *   where: {
     *     // ... filter to delete one CustomerProfile
     *   }
     * })
     *
     */
    delete<T extends CustomerProfileDeleteArgs>(
      args: SelectSubset<T, CustomerProfileDeleteArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one CustomerProfile.
     * @param {CustomerProfileUpdateArgs} args - Arguments to update one CustomerProfile.
     * @example
     * // Update one CustomerProfile
     * const customerProfile = await prisma.customerProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CustomerProfileUpdateArgs>(
      args: SelectSubset<T, CustomerProfileUpdateArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more CustomerProfiles.
     * @param {CustomerProfileDeleteManyArgs} args - Arguments to filter CustomerProfiles to delete.
     * @example
     * // Delete a few CustomerProfiles
     * const { count } = await prisma.customerProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CustomerProfileDeleteManyArgs>(
      args?: SelectSubset<T, CustomerProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CustomerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProfiles
     * const customerProfile = await prisma.customerProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CustomerProfileUpdateManyArgs>(
      args: SelectSubset<T, CustomerProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CustomerProfile.
     * @param {CustomerProfileUpsertArgs} args - Arguments to update or create a CustomerProfile.
     * @example
     * // Update or create a CustomerProfile
     * const customerProfile = await prisma.customerProfile.upsert({
     *   create: {
     *     // ... data to create a CustomerProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProfile we want to update
     *   }
     * })
     */
    upsert<T extends CustomerProfileUpsertArgs>(
      args: SelectSubset<T, CustomerProfileUpsertArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      $Result.GetResult<Prisma.$CustomerProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of CustomerProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileCountArgs} args - Arguments to filter CustomerProfiles to count.
     * @example
     * // Count the number of CustomerProfiles
     * const count = await prisma.customerProfile.count({
     *   where: {
     *     // ... the filter for the CustomerProfiles we want to count
     *   }
     * })
     **/
    count<T extends CustomerProfileCountArgs>(
      args?: Subset<T, CustomerProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CustomerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CustomerProfileAggregateArgs>(
      args: Subset<T, CustomerProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetCustomerProfileAggregateType<T>>;

    /**
     * Group by CustomerProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CustomerProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProfileGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CustomerProfileGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCustomerProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CustomerProfile model
     */
    readonly fields: CustomerProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    addresses<T extends CustomerProfile$addressesArgs<ExtArgs> = {}>(
      args?: Subset<T, CustomerProfile$addressesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'> | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CustomerProfile model
   */
  interface CustomerProfileFieldRefs {
    readonly id: FieldRef<'CustomerProfile', 'String'>;
    readonly userId: FieldRef<'CustomerProfile', 'String'>;
    readonly preferences: FieldRef<'CustomerProfile', 'Json'>;
    readonly createdAt: FieldRef<'CustomerProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'CustomerProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * CustomerProfile findUnique
   */
  export type CustomerProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where: CustomerProfileWhereUniqueInput;
  };

  /**
   * CustomerProfile findUniqueOrThrow
   */
  export type CustomerProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where: CustomerProfileWhereUniqueInput;
  };

  /**
   * CustomerProfile findFirst
   */
  export type CustomerProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where?: CustomerProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?:
      | CustomerProfileOrderByWithRelationInput
      | CustomerProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CustomerProfiles.
     */
    distinct?:
      | CustomerProfileScalarFieldEnum
      | CustomerProfileScalarFieldEnum[];
  };

  /**
   * CustomerProfile findFirstOrThrow
   */
  export type CustomerProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter, which CustomerProfile to fetch.
     */
    where?: CustomerProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?:
      | CustomerProfileOrderByWithRelationInput
      | CustomerProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CustomerProfiles.
     */
    distinct?:
      | CustomerProfileScalarFieldEnum
      | CustomerProfileScalarFieldEnum[];
  };

  /**
   * CustomerProfile findMany
   */
  export type CustomerProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter, which CustomerProfiles to fetch.
     */
    where?: CustomerProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CustomerProfiles to fetch.
     */
    orderBy?:
      | CustomerProfileOrderByWithRelationInput
      | CustomerProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CustomerProfiles.
     */
    cursor?: CustomerProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CustomerProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CustomerProfiles.
     */
    skip?: number;
    distinct?:
      | CustomerProfileScalarFieldEnum
      | CustomerProfileScalarFieldEnum[];
  };

  /**
   * CustomerProfile create
   */
  export type CustomerProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a CustomerProfile.
     */
    data: XOR<CustomerProfileCreateInput, CustomerProfileUncheckedCreateInput>;
  };

  /**
   * CustomerProfile createMany
   */
  export type CustomerProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CustomerProfiles.
     */
    data: CustomerProfileCreateManyInput | CustomerProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * CustomerProfile createManyAndReturn
   */
  export type CustomerProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many CustomerProfiles.
     */
    data: CustomerProfileCreateManyInput | CustomerProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * CustomerProfile update
   */
  export type CustomerProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a CustomerProfile.
     */
    data: XOR<CustomerProfileUpdateInput, CustomerProfileUncheckedUpdateInput>;
    /**
     * Choose, which CustomerProfile to update.
     */
    where: CustomerProfileWhereUniqueInput;
  };

  /**
   * CustomerProfile updateMany
   */
  export type CustomerProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CustomerProfiles.
     */
    data: XOR<
      CustomerProfileUpdateManyMutationInput,
      CustomerProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which CustomerProfiles to update
     */
    where?: CustomerProfileWhereInput;
  };

  /**
   * CustomerProfile upsert
   */
  export type CustomerProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the CustomerProfile to update in case it exists.
     */
    where: CustomerProfileWhereUniqueInput;
    /**
     * In case the CustomerProfile found by the `where` argument doesn't exist, create a new CustomerProfile with this data.
     */
    create: XOR<
      CustomerProfileCreateInput,
      CustomerProfileUncheckedCreateInput
    >;
    /**
     * In case the CustomerProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      CustomerProfileUpdateInput,
      CustomerProfileUncheckedUpdateInput
    >;
  };

  /**
   * CustomerProfile delete
   */
  export type CustomerProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
    /**
     * Filter which CustomerProfile to delete.
     */
    where: CustomerProfileWhereUniqueInput;
  };

  /**
   * CustomerProfile deleteMany
   */
  export type CustomerProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CustomerProfiles to delete
     */
    where?: CustomerProfileWhereInput;
  };

  /**
   * CustomerProfile.addresses
   */
  export type CustomerProfile$addressesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    where?: AddressWhereInput;
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    cursor?: AddressWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * CustomerProfile without action
   */
  export type CustomerProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CustomerProfile
     */
    select?: CustomerProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProfileInclude<ExtArgs> | null;
  };

  /**
   * Model VendorProfile
   */

  export type AggregateVendorProfile = {
    _count: VendorProfileCountAggregateOutputType | null;
    _avg: VendorProfileAvgAggregateOutputType | null;
    _sum: VendorProfileSumAggregateOutputType | null;
    _min: VendorProfileMinAggregateOutputType | null;
    _max: VendorProfileMaxAggregateOutputType | null;
  };

  export type VendorProfileAvgAggregateOutputType = {
    commissionRate: number | null;
    rating: number | null;
    totalSales: number | null;
  };

  export type VendorProfileSumAggregateOutputType = {
    commissionRate: number | null;
    rating: number | null;
    totalSales: number | null;
  };

  export type VendorProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    businessName: string | null;
    businessType: string | null;
    description: string | null;
    logo: string | null;
    website: string | null;
    subscriptionTier: $Enums.SubscriptionTier | null;
    commissionRate: number | null;
    isVerified: boolean | null;
    rating: number | null;
    totalSales: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VendorProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    businessName: string | null;
    businessType: string | null;
    description: string | null;
    logo: string | null;
    website: string | null;
    subscriptionTier: $Enums.SubscriptionTier | null;
    commissionRate: number | null;
    isVerified: boolean | null;
    rating: number | null;
    totalSales: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type VendorProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    businessName: number;
    businessType: number;
    description: number;
    logo: number;
    website: number;
    subscriptionTier: number;
    commissionRate: number;
    isVerified: number;
    rating: number;
    totalSales: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type VendorProfileAvgAggregateInputType = {
    commissionRate?: true;
    rating?: true;
    totalSales?: true;
  };

  export type VendorProfileSumAggregateInputType = {
    commissionRate?: true;
    rating?: true;
    totalSales?: true;
  };

  export type VendorProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    businessType?: true;
    description?: true;
    logo?: true;
    website?: true;
    subscriptionTier?: true;
    commissionRate?: true;
    isVerified?: true;
    rating?: true;
    totalSales?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VendorProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    businessType?: true;
    description?: true;
    logo?: true;
    website?: true;
    subscriptionTier?: true;
    commissionRate?: true;
    isVerified?: true;
    rating?: true;
    totalSales?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type VendorProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    businessType?: true;
    description?: true;
    logo?: true;
    website?: true;
    subscriptionTier?: true;
    commissionRate?: true;
    isVerified?: true;
    rating?: true;
    totalSales?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type VendorProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VendorProfile to aggregate.
     */
    where?: VendorProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?:
      | VendorProfileOrderByWithRelationInput
      | VendorProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: VendorProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VendorProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned VendorProfiles
     **/
    _count?: true | VendorProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: VendorProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: VendorProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: VendorProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: VendorProfileMaxAggregateInputType;
  };

  export type GetVendorProfileAggregateType<
    T extends VendorProfileAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateVendorProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorProfile[P]>
      : GetScalarType<T[P], AggregateVendorProfile[P]>;
  };

  export type VendorProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: VendorProfileWhereInput;
    orderBy?:
      | VendorProfileOrderByWithAggregationInput
      | VendorProfileOrderByWithAggregationInput[];
    by: VendorProfileScalarFieldEnum[] | VendorProfileScalarFieldEnum;
    having?: VendorProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: VendorProfileCountAggregateInputType | true;
    _avg?: VendorProfileAvgAggregateInputType;
    _sum?: VendorProfileSumAggregateInputType;
    _min?: VendorProfileMinAggregateInputType;
    _max?: VendorProfileMaxAggregateInputType;
  };

  export type VendorProfileGroupByOutputType = {
    id: string;
    userId: string;
    businessName: string;
    businessType: string;
    description: string | null;
    logo: string | null;
    website: string | null;
    subscriptionTier: $Enums.SubscriptionTier;
    commissionRate: number;
    isVerified: boolean;
    rating: number | null;
    totalSales: number;
    createdAt: Date;
    updatedAt: Date;
    _count: VendorProfileCountAggregateOutputType | null;
    _avg: VendorProfileAvgAggregateOutputType | null;
    _sum: VendorProfileSumAggregateOutputType | null;
    _min: VendorProfileMinAggregateOutputType | null;
    _max: VendorProfileMaxAggregateOutputType | null;
  };

  type GetVendorProfileGroupByPayload<T extends VendorProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<VendorProfileGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof VendorProfileGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorProfileGroupByOutputType[P]>
            : GetScalarType<T[P], VendorProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type VendorProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      businessName?: boolean;
      businessType?: boolean;
      description?: boolean;
      logo?: boolean;
      website?: boolean;
      subscriptionTier?: boolean;
      commissionRate?: boolean;
      isVerified?: boolean;
      rating?: boolean;
      totalSales?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['vendorProfile']
  >;

  export type VendorProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      businessName?: boolean;
      businessType?: boolean;
      description?: boolean;
      logo?: boolean;
      website?: boolean;
      subscriptionTier?: boolean;
      commissionRate?: boolean;
      isVerified?: boolean;
      rating?: boolean;
      totalSales?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['vendorProfile']
  >;

  export type VendorProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    businessName?: boolean;
    businessType?: boolean;
    description?: boolean;
    logo?: boolean;
    website?: boolean;
    subscriptionTier?: boolean;
    commissionRate?: boolean;
    isVerified?: boolean;
    rating?: boolean;
    totalSales?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type VendorProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type VendorProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $VendorProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'VendorProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        businessName: string;
        businessType: string;
        description: string | null;
        logo: string | null;
        website: string | null;
        subscriptionTier: $Enums.SubscriptionTier;
        commissionRate: number;
        isVerified: boolean;
        rating: number | null;
        totalSales: number;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['vendorProfile']
    >;
    composites: {};
  };

  type VendorProfileGetPayload<
    S extends boolean | null | undefined | VendorProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$VendorProfilePayload, S>;

  type VendorProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<VendorProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: VendorProfileCountAggregateInputType | true;
  };

  export interface VendorProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['VendorProfile'];
      meta: { name: 'VendorProfile' };
    };
    /**
     * Find zero or one VendorProfile that matches the filter.
     * @param {VendorProfileFindUniqueArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorProfileFindUniqueArgs>(
      args: SelectSubset<T, VendorProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one VendorProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorProfileFindUniqueOrThrowArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, VendorProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first VendorProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindFirstArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorProfileFindFirstArgs>(
      args?: SelectSubset<T, VendorProfileFindFirstArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first VendorProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindFirstOrThrowArgs} args - Arguments to find a VendorProfile
     * @example
     * // Get one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, VendorProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more VendorProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorProfiles
     * const vendorProfiles = await prisma.vendorProfile.findMany()
     *
     * // Get first 10 VendorProfiles
     * const vendorProfiles = await prisma.vendorProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const vendorProfileWithIdOnly = await prisma.vendorProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends VendorProfileFindManyArgs>(
      args?: SelectSubset<T, VendorProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a VendorProfile.
     * @param {VendorProfileCreateArgs} args - Arguments to create a VendorProfile.
     * @example
     * // Create one VendorProfile
     * const VendorProfile = await prisma.vendorProfile.create({
     *   data: {
     *     // ... data to create a VendorProfile
     *   }
     * })
     *
     */
    create<T extends VendorProfileCreateArgs>(
      args: SelectSubset<T, VendorProfileCreateArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many VendorProfiles.
     * @param {VendorProfileCreateManyArgs} args - Arguments to create many VendorProfiles.
     * @example
     * // Create many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends VendorProfileCreateManyArgs>(
      args?: SelectSubset<T, VendorProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many VendorProfiles and returns the data saved in the database.
     * @param {VendorProfileCreateManyAndReturnArgs} args - Arguments to create many VendorProfiles.
     * @example
     * // Create many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many VendorProfiles and only return the `id`
     * const vendorProfileWithIdOnly = await prisma.vendorProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends VendorProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, VendorProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$VendorProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a VendorProfile.
     * @param {VendorProfileDeleteArgs} args - Arguments to delete one VendorProfile.
     * @example
     * // Delete one VendorProfile
     * const VendorProfile = await prisma.vendorProfile.delete({
     *   where: {
     *     // ... filter to delete one VendorProfile
     *   }
     * })
     *
     */
    delete<T extends VendorProfileDeleteArgs>(
      args: SelectSubset<T, VendorProfileDeleteArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one VendorProfile.
     * @param {VendorProfileUpdateArgs} args - Arguments to update one VendorProfile.
     * @example
     * // Update one VendorProfile
     * const vendorProfile = await prisma.vendorProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends VendorProfileUpdateArgs>(
      args: SelectSubset<T, VendorProfileUpdateArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more VendorProfiles.
     * @param {VendorProfileDeleteManyArgs} args - Arguments to filter VendorProfiles to delete.
     * @example
     * // Delete a few VendorProfiles
     * const { count } = await prisma.vendorProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends VendorProfileDeleteManyArgs>(
      args?: SelectSubset<T, VendorProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more VendorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorProfiles
     * const vendorProfile = await prisma.vendorProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends VendorProfileUpdateManyArgs>(
      args: SelectSubset<T, VendorProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one VendorProfile.
     * @param {VendorProfileUpsertArgs} args - Arguments to update or create a VendorProfile.
     * @example
     * // Update or create a VendorProfile
     * const vendorProfile = await prisma.vendorProfile.upsert({
     *   create: {
     *     // ... data to create a VendorProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorProfile we want to update
     *   }
     * })
     */
    upsert<T extends VendorProfileUpsertArgs>(
      args: SelectSubset<T, VendorProfileUpsertArgs<ExtArgs>>
    ): Prisma__VendorProfileClient<
      $Result.GetResult<Prisma.$VendorProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of VendorProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileCountArgs} args - Arguments to filter VendorProfiles to count.
     * @example
     * // Count the number of VendorProfiles
     * const count = await prisma.vendorProfile.count({
     *   where: {
     *     // ... the filter for the VendorProfiles we want to count
     *   }
     * })
     **/
    count<T extends VendorProfileCountArgs>(
      args?: Subset<T, VendorProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a VendorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends VendorProfileAggregateArgs>(
      args: Subset<T, VendorProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetVendorProfileAggregateType<T>>;

    /**
     * Group by VendorProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends VendorProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorProfileGroupByArgs['orderBy'] }
        : { orderBy?: VendorProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, VendorProfileGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetVendorProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the VendorProfile model
     */
    readonly fields: VendorProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the VendorProfile model
   */
  interface VendorProfileFieldRefs {
    readonly id: FieldRef<'VendorProfile', 'String'>;
    readonly userId: FieldRef<'VendorProfile', 'String'>;
    readonly businessName: FieldRef<'VendorProfile', 'String'>;
    readonly businessType: FieldRef<'VendorProfile', 'String'>;
    readonly description: FieldRef<'VendorProfile', 'String'>;
    readonly logo: FieldRef<'VendorProfile', 'String'>;
    readonly website: FieldRef<'VendorProfile', 'String'>;
    readonly subscriptionTier: FieldRef<'VendorProfile', 'SubscriptionTier'>;
    readonly commissionRate: FieldRef<'VendorProfile', 'Float'>;
    readonly isVerified: FieldRef<'VendorProfile', 'Boolean'>;
    readonly rating: FieldRef<'VendorProfile', 'Float'>;
    readonly totalSales: FieldRef<'VendorProfile', 'Float'>;
    readonly createdAt: FieldRef<'VendorProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'VendorProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * VendorProfile findUnique
   */
  export type VendorProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter, which VendorProfile to fetch.
     */
    where: VendorProfileWhereUniqueInput;
  };

  /**
   * VendorProfile findUniqueOrThrow
   */
  export type VendorProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter, which VendorProfile to fetch.
     */
    where: VendorProfileWhereUniqueInput;
  };

  /**
   * VendorProfile findFirst
   */
  export type VendorProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter, which VendorProfile to fetch.
     */
    where?: VendorProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?:
      | VendorProfileOrderByWithRelationInput
      | VendorProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VendorProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VendorProfiles.
     */
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[];
  };

  /**
   * VendorProfile findFirstOrThrow
   */
  export type VendorProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter, which VendorProfile to fetch.
     */
    where?: VendorProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?:
      | VendorProfileOrderByWithRelationInput
      | VendorProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VendorProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of VendorProfiles.
     */
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[];
  };

  /**
   * VendorProfile findMany
   */
  export type VendorProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter, which VendorProfiles to fetch.
     */
    where?: VendorProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of VendorProfiles to fetch.
     */
    orderBy?:
      | VendorProfileOrderByWithRelationInput
      | VendorProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing VendorProfiles.
     */
    cursor?: VendorProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` VendorProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` VendorProfiles.
     */
    skip?: number;
    distinct?: VendorProfileScalarFieldEnum | VendorProfileScalarFieldEnum[];
  };

  /**
   * VendorProfile create
   */
  export type VendorProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a VendorProfile.
     */
    data: XOR<VendorProfileCreateInput, VendorProfileUncheckedCreateInput>;
  };

  /**
   * VendorProfile createMany
   */
  export type VendorProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many VendorProfiles.
     */
    data: VendorProfileCreateManyInput | VendorProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * VendorProfile createManyAndReturn
   */
  export type VendorProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many VendorProfiles.
     */
    data: VendorProfileCreateManyInput | VendorProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * VendorProfile update
   */
  export type VendorProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a VendorProfile.
     */
    data: XOR<VendorProfileUpdateInput, VendorProfileUncheckedUpdateInput>;
    /**
     * Choose, which VendorProfile to update.
     */
    where: VendorProfileWhereUniqueInput;
  };

  /**
   * VendorProfile updateMany
   */
  export type VendorProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update VendorProfiles.
     */
    data: XOR<
      VendorProfileUpdateManyMutationInput,
      VendorProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which VendorProfiles to update
     */
    where?: VendorProfileWhereInput;
  };

  /**
   * VendorProfile upsert
   */
  export type VendorProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the VendorProfile to update in case it exists.
     */
    where: VendorProfileWhereUniqueInput;
    /**
     * In case the VendorProfile found by the `where` argument doesn't exist, create a new VendorProfile with this data.
     */
    create: XOR<VendorProfileCreateInput, VendorProfileUncheckedCreateInput>;
    /**
     * In case the VendorProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorProfileUpdateInput, VendorProfileUncheckedUpdateInput>;
  };

  /**
   * VendorProfile delete
   */
  export type VendorProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
    /**
     * Filter which VendorProfile to delete.
     */
    where: VendorProfileWhereUniqueInput;
  };

  /**
   * VendorProfile deleteMany
   */
  export type VendorProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which VendorProfiles to delete
     */
    where?: VendorProfileWhereInput;
  };

  /**
   * VendorProfile without action
   */
  export type VendorProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the VendorProfile
     */
    select?: VendorProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorProfileInclude<ExtArgs> | null;
  };

  /**
   * Model DriverProfile
   */

  export type AggregateDriverProfile = {
    _count: DriverProfileCountAggregateOutputType | null;
    _avg: DriverProfileAvgAggregateOutputType | null;
    _sum: DriverProfileSumAggregateOutputType | null;
    _min: DriverProfileMinAggregateOutputType | null;
    _max: DriverProfileMaxAggregateOutputType | null;
  };

  export type DriverProfileAvgAggregateOutputType = {
    rating: number | null;
    totalRides: number | null;
  };

  export type DriverProfileSumAggregateOutputType = {
    rating: number | null;
    totalRides: number | null;
  };

  export type DriverProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    licenseNumber: string | null;
    isOnline: boolean | null;
    rating: number | null;
    totalRides: number | null;
    isVerified: boolean | null;
    subscriptionTier: $Enums.DriverTier | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DriverProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    licenseNumber: string | null;
    isOnline: boolean | null;
    rating: number | null;
    totalRides: number | null;
    isVerified: boolean | null;
    subscriptionTier: $Enums.DriverTier | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type DriverProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    licenseNumber: number;
    vehicleInfo: number;
    isOnline: number;
    currentLocation: number;
    rating: number;
    totalRides: number;
    isVerified: number;
    subscriptionTier: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type DriverProfileAvgAggregateInputType = {
    rating?: true;
    totalRides?: true;
  };

  export type DriverProfileSumAggregateInputType = {
    rating?: true;
    totalRides?: true;
  };

  export type DriverProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    licenseNumber?: true;
    isOnline?: true;
    rating?: true;
    totalRides?: true;
    isVerified?: true;
    subscriptionTier?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DriverProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    licenseNumber?: true;
    isOnline?: true;
    rating?: true;
    totalRides?: true;
    isVerified?: true;
    subscriptionTier?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type DriverProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    licenseNumber?: true;
    vehicleInfo?: true;
    isOnline?: true;
    currentLocation?: true;
    rating?: true;
    totalRides?: true;
    isVerified?: true;
    subscriptionTier?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type DriverProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DriverProfile to aggregate.
     */
    where?: DriverProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DriverProfiles to fetch.
     */
    orderBy?:
      | DriverProfileOrderByWithRelationInput
      | DriverProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: DriverProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DriverProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DriverProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned DriverProfiles
     **/
    _count?: true | DriverProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: DriverProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: DriverProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: DriverProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: DriverProfileMaxAggregateInputType;
  };

  export type GetDriverProfileAggregateType<
    T extends DriverProfileAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateDriverProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriverProfile[P]>
      : GetScalarType<T[P], AggregateDriverProfile[P]>;
  };

  export type DriverProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: DriverProfileWhereInput;
    orderBy?:
      | DriverProfileOrderByWithAggregationInput
      | DriverProfileOrderByWithAggregationInput[];
    by: DriverProfileScalarFieldEnum[] | DriverProfileScalarFieldEnum;
    having?: DriverProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: DriverProfileCountAggregateInputType | true;
    _avg?: DriverProfileAvgAggregateInputType;
    _sum?: DriverProfileSumAggregateInputType;
    _min?: DriverProfileMinAggregateInputType;
    _max?: DriverProfileMaxAggregateInputType;
  };

  export type DriverProfileGroupByOutputType = {
    id: string;
    userId: string;
    licenseNumber: string;
    vehicleInfo: JsonValue;
    isOnline: boolean;
    currentLocation: JsonValue | null;
    rating: number | null;
    totalRides: number;
    isVerified: boolean;
    subscriptionTier: $Enums.DriverTier;
    createdAt: Date;
    updatedAt: Date;
    _count: DriverProfileCountAggregateOutputType | null;
    _avg: DriverProfileAvgAggregateOutputType | null;
    _sum: DriverProfileSumAggregateOutputType | null;
    _min: DriverProfileMinAggregateOutputType | null;
    _max: DriverProfileMaxAggregateOutputType | null;
  };

  type GetDriverProfileGroupByPayload<T extends DriverProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<DriverProfileGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof DriverProfileGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverProfileGroupByOutputType[P]>
            : GetScalarType<T[P], DriverProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type DriverProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      licenseNumber?: boolean;
      vehicleInfo?: boolean;
      isOnline?: boolean;
      currentLocation?: boolean;
      rating?: boolean;
      totalRides?: boolean;
      isVerified?: boolean;
      subscriptionTier?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['driverProfile']
  >;

  export type DriverProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      licenseNumber?: boolean;
      vehicleInfo?: boolean;
      isOnline?: boolean;
      currentLocation?: boolean;
      rating?: boolean;
      totalRides?: boolean;
      isVerified?: boolean;
      subscriptionTier?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['driverProfile']
  >;

  export type DriverProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    licenseNumber?: boolean;
    vehicleInfo?: boolean;
    isOnline?: boolean;
    currentLocation?: boolean;
    rating?: boolean;
    totalRides?: boolean;
    isVerified?: boolean;
    subscriptionTier?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type DriverProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type DriverProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $DriverProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'DriverProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        licenseNumber: string;
        vehicleInfo: Prisma.JsonValue;
        isOnline: boolean;
        currentLocation: Prisma.JsonValue | null;
        rating: number | null;
        totalRides: number;
        isVerified: boolean;
        subscriptionTier: $Enums.DriverTier;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['driverProfile']
    >;
    composites: {};
  };

  type DriverProfileGetPayload<
    S extends boolean | null | undefined | DriverProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$DriverProfilePayload, S>;

  type DriverProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<DriverProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: DriverProfileCountAggregateInputType | true;
  };

  export interface DriverProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['DriverProfile'];
      meta: { name: 'DriverProfile' };
    };
    /**
     * Find zero or one DriverProfile that matches the filter.
     * @param {DriverProfileFindUniqueArgs} args - Arguments to find a DriverProfile
     * @example
     * // Get one DriverProfile
     * const driverProfile = await prisma.driverProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverProfileFindUniqueArgs>(
      args: SelectSubset<T, DriverProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one DriverProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverProfileFindUniqueOrThrowArgs} args - Arguments to find a DriverProfile
     * @example
     * // Get one DriverProfile
     * const driverProfile = await prisma.driverProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, DriverProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first DriverProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileFindFirstArgs} args - Arguments to find a DriverProfile
     * @example
     * // Get one DriverProfile
     * const driverProfile = await prisma.driverProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverProfileFindFirstArgs>(
      args?: SelectSubset<T, DriverProfileFindFirstArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first DriverProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileFindFirstOrThrowArgs} args - Arguments to find a DriverProfile
     * @example
     * // Get one DriverProfile
     * const driverProfile = await prisma.driverProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DriverProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more DriverProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DriverProfiles
     * const driverProfiles = await prisma.driverProfile.findMany()
     *
     * // Get first 10 DriverProfiles
     * const driverProfiles = await prisma.driverProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const driverProfileWithIdOnly = await prisma.driverProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends DriverProfileFindManyArgs>(
      args?: SelectSubset<T, DriverProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$DriverProfilePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a DriverProfile.
     * @param {DriverProfileCreateArgs} args - Arguments to create a DriverProfile.
     * @example
     * // Create one DriverProfile
     * const DriverProfile = await prisma.driverProfile.create({
     *   data: {
     *     // ... data to create a DriverProfile
     *   }
     * })
     *
     */
    create<T extends DriverProfileCreateArgs>(
      args: SelectSubset<T, DriverProfileCreateArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<Prisma.$DriverProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many DriverProfiles.
     * @param {DriverProfileCreateManyArgs} args - Arguments to create many DriverProfiles.
     * @example
     * // Create many DriverProfiles
     * const driverProfile = await prisma.driverProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends DriverProfileCreateManyArgs>(
      args?: SelectSubset<T, DriverProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many DriverProfiles and returns the data saved in the database.
     * @param {DriverProfileCreateManyAndReturnArgs} args - Arguments to create many DriverProfiles.
     * @example
     * // Create many DriverProfiles
     * const driverProfile = await prisma.driverProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many DriverProfiles and only return the `id`
     * const driverProfileWithIdOnly = await prisma.driverProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends DriverProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, DriverProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$DriverProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a DriverProfile.
     * @param {DriverProfileDeleteArgs} args - Arguments to delete one DriverProfile.
     * @example
     * // Delete one DriverProfile
     * const DriverProfile = await prisma.driverProfile.delete({
     *   where: {
     *     // ... filter to delete one DriverProfile
     *   }
     * })
     *
     */
    delete<T extends DriverProfileDeleteArgs>(
      args: SelectSubset<T, DriverProfileDeleteArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<Prisma.$DriverProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one DriverProfile.
     * @param {DriverProfileUpdateArgs} args - Arguments to update one DriverProfile.
     * @example
     * // Update one DriverProfile
     * const driverProfile = await prisma.driverProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends DriverProfileUpdateArgs>(
      args: SelectSubset<T, DriverProfileUpdateArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<Prisma.$DriverProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more DriverProfiles.
     * @param {DriverProfileDeleteManyArgs} args - Arguments to filter DriverProfiles to delete.
     * @example
     * // Delete a few DriverProfiles
     * const { count } = await prisma.driverProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends DriverProfileDeleteManyArgs>(
      args?: SelectSubset<T, DriverProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more DriverProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DriverProfiles
     * const driverProfile = await prisma.driverProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends DriverProfileUpdateManyArgs>(
      args: SelectSubset<T, DriverProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one DriverProfile.
     * @param {DriverProfileUpsertArgs} args - Arguments to update or create a DriverProfile.
     * @example
     * // Update or create a DriverProfile
     * const driverProfile = await prisma.driverProfile.upsert({
     *   create: {
     *     // ... data to create a DriverProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DriverProfile we want to update
     *   }
     * })
     */
    upsert<T extends DriverProfileUpsertArgs>(
      args: SelectSubset<T, DriverProfileUpsertArgs<ExtArgs>>
    ): Prisma__DriverProfileClient<
      $Result.GetResult<Prisma.$DriverProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of DriverProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileCountArgs} args - Arguments to filter DriverProfiles to count.
     * @example
     * // Count the number of DriverProfiles
     * const count = await prisma.driverProfile.count({
     *   where: {
     *     // ... the filter for the DriverProfiles we want to count
     *   }
     * })
     **/
    count<T extends DriverProfileCountArgs>(
      args?: Subset<T, DriverProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a DriverProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends DriverProfileAggregateArgs>(
      args: Subset<T, DriverProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetDriverProfileAggregateType<T>>;

    /**
     * Group by DriverProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends DriverProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverProfileGroupByArgs['orderBy'] }
        : { orderBy?: DriverProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, DriverProfileGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetDriverProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the DriverProfile model
     */
    readonly fields: DriverProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DriverProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the DriverProfile model
   */
  interface DriverProfileFieldRefs {
    readonly id: FieldRef<'DriverProfile', 'String'>;
    readonly userId: FieldRef<'DriverProfile', 'String'>;
    readonly licenseNumber: FieldRef<'DriverProfile', 'String'>;
    readonly vehicleInfo: FieldRef<'DriverProfile', 'Json'>;
    readonly isOnline: FieldRef<'DriverProfile', 'Boolean'>;
    readonly currentLocation: FieldRef<'DriverProfile', 'Json'>;
    readonly rating: FieldRef<'DriverProfile', 'Float'>;
    readonly totalRides: FieldRef<'DriverProfile', 'Int'>;
    readonly isVerified: FieldRef<'DriverProfile', 'Boolean'>;
    readonly subscriptionTier: FieldRef<'DriverProfile', 'DriverTier'>;
    readonly createdAt: FieldRef<'DriverProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'DriverProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * DriverProfile findUnique
   */
  export type DriverProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DriverProfile to fetch.
     */
    where: DriverProfileWhereUniqueInput;
  };

  /**
   * DriverProfile findUniqueOrThrow
   */
  export type DriverProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DriverProfile to fetch.
     */
    where: DriverProfileWhereUniqueInput;
  };

  /**
   * DriverProfile findFirst
   */
  export type DriverProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DriverProfile to fetch.
     */
    where?: DriverProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DriverProfiles to fetch.
     */
    orderBy?:
      | DriverProfileOrderByWithRelationInput
      | DriverProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DriverProfiles.
     */
    cursor?: DriverProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DriverProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DriverProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DriverProfiles.
     */
    distinct?: DriverProfileScalarFieldEnum | DriverProfileScalarFieldEnum[];
  };

  /**
   * DriverProfile findFirstOrThrow
   */
  export type DriverProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DriverProfile to fetch.
     */
    where?: DriverProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DriverProfiles to fetch.
     */
    orderBy?:
      | DriverProfileOrderByWithRelationInput
      | DriverProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for DriverProfiles.
     */
    cursor?: DriverProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DriverProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DriverProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of DriverProfiles.
     */
    distinct?: DriverProfileScalarFieldEnum | DriverProfileScalarFieldEnum[];
  };

  /**
   * DriverProfile findMany
   */
  export type DriverProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter, which DriverProfiles to fetch.
     */
    where?: DriverProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of DriverProfiles to fetch.
     */
    orderBy?:
      | DriverProfileOrderByWithRelationInput
      | DriverProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing DriverProfiles.
     */
    cursor?: DriverProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` DriverProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` DriverProfiles.
     */
    skip?: number;
    distinct?: DriverProfileScalarFieldEnum | DriverProfileScalarFieldEnum[];
  };

  /**
   * DriverProfile create
   */
  export type DriverProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a DriverProfile.
     */
    data: XOR<DriverProfileCreateInput, DriverProfileUncheckedCreateInput>;
  };

  /**
   * DriverProfile createMany
   */
  export type DriverProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many DriverProfiles.
     */
    data: DriverProfileCreateManyInput | DriverProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * DriverProfile createManyAndReturn
   */
  export type DriverProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many DriverProfiles.
     */
    data: DriverProfileCreateManyInput | DriverProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * DriverProfile update
   */
  export type DriverProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a DriverProfile.
     */
    data: XOR<DriverProfileUpdateInput, DriverProfileUncheckedUpdateInput>;
    /**
     * Choose, which DriverProfile to update.
     */
    where: DriverProfileWhereUniqueInput;
  };

  /**
   * DriverProfile updateMany
   */
  export type DriverProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update DriverProfiles.
     */
    data: XOR<
      DriverProfileUpdateManyMutationInput,
      DriverProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which DriverProfiles to update
     */
    where?: DriverProfileWhereInput;
  };

  /**
   * DriverProfile upsert
   */
  export type DriverProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the DriverProfile to update in case it exists.
     */
    where: DriverProfileWhereUniqueInput;
    /**
     * In case the DriverProfile found by the `where` argument doesn't exist, create a new DriverProfile with this data.
     */
    create: XOR<DriverProfileCreateInput, DriverProfileUncheckedCreateInput>;
    /**
     * In case the DriverProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverProfileUpdateInput, DriverProfileUncheckedUpdateInput>;
  };

  /**
   * DriverProfile delete
   */
  export type DriverProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
    /**
     * Filter which DriverProfile to delete.
     */
    where: DriverProfileWhereUniqueInput;
  };

  /**
   * DriverProfile deleteMany
   */
  export type DriverProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which DriverProfiles to delete
     */
    where?: DriverProfileWhereInput;
  };

  /**
   * DriverProfile without action
   */
  export type DriverProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the DriverProfile
     */
    select?: DriverProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverProfileInclude<ExtArgs> | null;
  };

  /**
   * Model HostProfile
   */

  export type AggregateHostProfile = {
    _count: HostProfileCountAggregateOutputType | null;
    _avg: HostProfileAvgAggregateOutputType | null;
    _sum: HostProfileSumAggregateOutputType | null;
    _min: HostProfileMinAggregateOutputType | null;
    _max: HostProfileMaxAggregateOutputType | null;
  };

  export type HostProfileAvgAggregateOutputType = {
    rating: number | null;
    totalBookings: number | null;
    responseRate: number | null;
    responseTime: number | null;
  };

  export type HostProfileSumAggregateOutputType = {
    rating: number | null;
    totalBookings: number | null;
    responseRate: number | null;
    responseTime: number | null;
  };

  export type HostProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    businessName: string | null;
    description: string | null;
    rating: number | null;
    totalBookings: number | null;
    isVerified: boolean | null;
    subscriptionTier: $Enums.HostTier | null;
    responseRate: number | null;
    responseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HostProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    businessName: string | null;
    description: string | null;
    rating: number | null;
    totalBookings: number | null;
    isVerified: boolean | null;
    subscriptionTier: $Enums.HostTier | null;
    responseRate: number | null;
    responseTime: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type HostProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    businessName: number;
    description: number;
    rating: number;
    totalBookings: number;
    isVerified: number;
    subscriptionTier: number;
    responseRate: number;
    responseTime: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type HostProfileAvgAggregateInputType = {
    rating?: true;
    totalBookings?: true;
    responseRate?: true;
    responseTime?: true;
  };

  export type HostProfileSumAggregateInputType = {
    rating?: true;
    totalBookings?: true;
    responseRate?: true;
    responseTime?: true;
  };

  export type HostProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    description?: true;
    rating?: true;
    totalBookings?: true;
    isVerified?: true;
    subscriptionTier?: true;
    responseRate?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HostProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    description?: true;
    rating?: true;
    totalBookings?: true;
    isVerified?: true;
    subscriptionTier?: true;
    responseRate?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type HostProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    businessName?: true;
    description?: true;
    rating?: true;
    totalBookings?: true;
    isVerified?: true;
    subscriptionTier?: true;
    responseRate?: true;
    responseTime?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type HostProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HostProfile to aggregate.
     */
    where?: HostProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HostProfiles to fetch.
     */
    orderBy?:
      | HostProfileOrderByWithRelationInput
      | HostProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: HostProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HostProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HostProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned HostProfiles
     **/
    _count?: true | HostProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: HostProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: HostProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: HostProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: HostProfileMaxAggregateInputType;
  };

  export type GetHostProfileAggregateType<T extends HostProfileAggregateArgs> =
    {
      [P in keyof T & keyof AggregateHostProfile]: P extends '_count' | 'count'
        ? T[P] extends true
          ? number
          : GetScalarType<T[P], AggregateHostProfile[P]>
        : GetScalarType<T[P], AggregateHostProfile[P]>;
    };

  export type HostProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: HostProfileWhereInput;
    orderBy?:
      | HostProfileOrderByWithAggregationInput
      | HostProfileOrderByWithAggregationInput[];
    by: HostProfileScalarFieldEnum[] | HostProfileScalarFieldEnum;
    having?: HostProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: HostProfileCountAggregateInputType | true;
    _avg?: HostProfileAvgAggregateInputType;
    _sum?: HostProfileSumAggregateInputType;
    _min?: HostProfileMinAggregateInputType;
    _max?: HostProfileMaxAggregateInputType;
  };

  export type HostProfileGroupByOutputType = {
    id: string;
    userId: string;
    businessName: string | null;
    description: string | null;
    rating: number | null;
    totalBookings: number;
    isVerified: boolean;
    subscriptionTier: $Enums.HostTier;
    responseRate: number | null;
    responseTime: number | null;
    createdAt: Date;
    updatedAt: Date;
    _count: HostProfileCountAggregateOutputType | null;
    _avg: HostProfileAvgAggregateOutputType | null;
    _sum: HostProfileSumAggregateOutputType | null;
    _min: HostProfileMinAggregateOutputType | null;
    _max: HostProfileMaxAggregateOutputType | null;
  };

  type GetHostProfileGroupByPayload<T extends HostProfileGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<HostProfileGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof HostProfileGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HostProfileGroupByOutputType[P]>
            : GetScalarType<T[P], HostProfileGroupByOutputType[P]>;
        }
      >
    >;

  export type HostProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      businessName?: boolean;
      description?: boolean;
      rating?: boolean;
      totalBookings?: boolean;
      isVerified?: boolean;
      subscriptionTier?: boolean;
      responseRate?: boolean;
      responseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['hostProfile']
  >;

  export type HostProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      businessName?: boolean;
      description?: boolean;
      rating?: boolean;
      totalBookings?: boolean;
      isVerified?: boolean;
      subscriptionTier?: boolean;
      responseRate?: boolean;
      responseTime?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['hostProfile']
  >;

  export type HostProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    businessName?: boolean;
    description?: boolean;
    rating?: boolean;
    totalBookings?: boolean;
    isVerified?: boolean;
    subscriptionTier?: boolean;
    responseRate?: boolean;
    responseTime?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type HostProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type HostProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $HostProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'HostProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        businessName: string | null;
        description: string | null;
        rating: number | null;
        totalBookings: number;
        isVerified: boolean;
        subscriptionTier: $Enums.HostTier;
        responseRate: number | null;
        responseTime: number | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['hostProfile']
    >;
    composites: {};
  };

  type HostProfileGetPayload<
    S extends boolean | null | undefined | HostProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$HostProfilePayload, S>;

  type HostProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<HostProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: HostProfileCountAggregateInputType | true;
  };

  export interface HostProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['HostProfile'];
      meta: { name: 'HostProfile' };
    };
    /**
     * Find zero or one HostProfile that matches the filter.
     * @param {HostProfileFindUniqueArgs} args - Arguments to find a HostProfile
     * @example
     * // Get one HostProfile
     * const hostProfile = await prisma.hostProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HostProfileFindUniqueArgs>(
      args: SelectSubset<T, HostProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one HostProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HostProfileFindUniqueOrThrowArgs} args - Arguments to find a HostProfile
     * @example
     * // Get one HostProfile
     * const hostProfile = await prisma.hostProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HostProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, HostProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first HostProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileFindFirstArgs} args - Arguments to find a HostProfile
     * @example
     * // Get one HostProfile
     * const hostProfile = await prisma.hostProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HostProfileFindFirstArgs>(
      args?: SelectSubset<T, HostProfileFindFirstArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first HostProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileFindFirstOrThrowArgs} args - Arguments to find a HostProfile
     * @example
     * // Get one HostProfile
     * const hostProfile = await prisma.hostProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HostProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HostProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more HostProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HostProfiles
     * const hostProfiles = await prisma.hostProfile.findMany()
     *
     * // Get first 10 HostProfiles
     * const hostProfiles = await prisma.hostProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const hostProfileWithIdOnly = await prisma.hostProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends HostProfileFindManyArgs>(
      args?: SelectSubset<T, HostProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$HostProfilePayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a HostProfile.
     * @param {HostProfileCreateArgs} args - Arguments to create a HostProfile.
     * @example
     * // Create one HostProfile
     * const HostProfile = await prisma.hostProfile.create({
     *   data: {
     *     // ... data to create a HostProfile
     *   }
     * })
     *
     */
    create<T extends HostProfileCreateArgs>(
      args: SelectSubset<T, HostProfileCreateArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<Prisma.$HostProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many HostProfiles.
     * @param {HostProfileCreateManyArgs} args - Arguments to create many HostProfiles.
     * @example
     * // Create many HostProfiles
     * const hostProfile = await prisma.hostProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends HostProfileCreateManyArgs>(
      args?: SelectSubset<T, HostProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many HostProfiles and returns the data saved in the database.
     * @param {HostProfileCreateManyAndReturnArgs} args - Arguments to create many HostProfiles.
     * @example
     * // Create many HostProfiles
     * const hostProfile = await prisma.hostProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many HostProfiles and only return the `id`
     * const hostProfileWithIdOnly = await prisma.hostProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends HostProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, HostProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$HostProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a HostProfile.
     * @param {HostProfileDeleteArgs} args - Arguments to delete one HostProfile.
     * @example
     * // Delete one HostProfile
     * const HostProfile = await prisma.hostProfile.delete({
     *   where: {
     *     // ... filter to delete one HostProfile
     *   }
     * })
     *
     */
    delete<T extends HostProfileDeleteArgs>(
      args: SelectSubset<T, HostProfileDeleteArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<Prisma.$HostProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one HostProfile.
     * @param {HostProfileUpdateArgs} args - Arguments to update one HostProfile.
     * @example
     * // Update one HostProfile
     * const hostProfile = await prisma.hostProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends HostProfileUpdateArgs>(
      args: SelectSubset<T, HostProfileUpdateArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<Prisma.$HostProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more HostProfiles.
     * @param {HostProfileDeleteManyArgs} args - Arguments to filter HostProfiles to delete.
     * @example
     * // Delete a few HostProfiles
     * const { count } = await prisma.hostProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends HostProfileDeleteManyArgs>(
      args?: SelectSubset<T, HostProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more HostProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HostProfiles
     * const hostProfile = await prisma.hostProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends HostProfileUpdateManyArgs>(
      args: SelectSubset<T, HostProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one HostProfile.
     * @param {HostProfileUpsertArgs} args - Arguments to update or create a HostProfile.
     * @example
     * // Update or create a HostProfile
     * const hostProfile = await prisma.hostProfile.upsert({
     *   create: {
     *     // ... data to create a HostProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HostProfile we want to update
     *   }
     * })
     */
    upsert<T extends HostProfileUpsertArgs>(
      args: SelectSubset<T, HostProfileUpsertArgs<ExtArgs>>
    ): Prisma__HostProfileClient<
      $Result.GetResult<Prisma.$HostProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of HostProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileCountArgs} args - Arguments to filter HostProfiles to count.
     * @example
     * // Count the number of HostProfiles
     * const count = await prisma.hostProfile.count({
     *   where: {
     *     // ... the filter for the HostProfiles we want to count
     *   }
     * })
     **/
    count<T extends HostProfileCountArgs>(
      args?: Subset<T, HostProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HostProfileCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a HostProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends HostProfileAggregateArgs>(
      args: Subset<T, HostProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetHostProfileAggregateType<T>>;

    /**
     * Group by HostProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HostProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends HostProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HostProfileGroupByArgs['orderBy'] }
        : { orderBy?: HostProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, HostProfileGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetHostProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the HostProfile model
     */
    readonly fields: HostProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HostProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HostProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the HostProfile model
   */
  interface HostProfileFieldRefs {
    readonly id: FieldRef<'HostProfile', 'String'>;
    readonly userId: FieldRef<'HostProfile', 'String'>;
    readonly businessName: FieldRef<'HostProfile', 'String'>;
    readonly description: FieldRef<'HostProfile', 'String'>;
    readonly rating: FieldRef<'HostProfile', 'Float'>;
    readonly totalBookings: FieldRef<'HostProfile', 'Int'>;
    readonly isVerified: FieldRef<'HostProfile', 'Boolean'>;
    readonly subscriptionTier: FieldRef<'HostProfile', 'HostTier'>;
    readonly responseRate: FieldRef<'HostProfile', 'Float'>;
    readonly responseTime: FieldRef<'HostProfile', 'Int'>;
    readonly createdAt: FieldRef<'HostProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'HostProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * HostProfile findUnique
   */
  export type HostProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HostProfile to fetch.
     */
    where: HostProfileWhereUniqueInput;
  };

  /**
   * HostProfile findUniqueOrThrow
   */
  export type HostProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HostProfile to fetch.
     */
    where: HostProfileWhereUniqueInput;
  };

  /**
   * HostProfile findFirst
   */
  export type HostProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HostProfile to fetch.
     */
    where?: HostProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HostProfiles to fetch.
     */
    orderBy?:
      | HostProfileOrderByWithRelationInput
      | HostProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HostProfiles.
     */
    cursor?: HostProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HostProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HostProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HostProfiles.
     */
    distinct?: HostProfileScalarFieldEnum | HostProfileScalarFieldEnum[];
  };

  /**
   * HostProfile findFirstOrThrow
   */
  export type HostProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HostProfile to fetch.
     */
    where?: HostProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HostProfiles to fetch.
     */
    orderBy?:
      | HostProfileOrderByWithRelationInput
      | HostProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for HostProfiles.
     */
    cursor?: HostProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HostProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HostProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of HostProfiles.
     */
    distinct?: HostProfileScalarFieldEnum | HostProfileScalarFieldEnum[];
  };

  /**
   * HostProfile findMany
   */
  export type HostProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter, which HostProfiles to fetch.
     */
    where?: HostProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of HostProfiles to fetch.
     */
    orderBy?:
      | HostProfileOrderByWithRelationInput
      | HostProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing HostProfiles.
     */
    cursor?: HostProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` HostProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` HostProfiles.
     */
    skip?: number;
    distinct?: HostProfileScalarFieldEnum | HostProfileScalarFieldEnum[];
  };

  /**
   * HostProfile create
   */
  export type HostProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a HostProfile.
     */
    data: XOR<HostProfileCreateInput, HostProfileUncheckedCreateInput>;
  };

  /**
   * HostProfile createMany
   */
  export type HostProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many HostProfiles.
     */
    data: HostProfileCreateManyInput | HostProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * HostProfile createManyAndReturn
   */
  export type HostProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many HostProfiles.
     */
    data: HostProfileCreateManyInput | HostProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * HostProfile update
   */
  export type HostProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a HostProfile.
     */
    data: XOR<HostProfileUpdateInput, HostProfileUncheckedUpdateInput>;
    /**
     * Choose, which HostProfile to update.
     */
    where: HostProfileWhereUniqueInput;
  };

  /**
   * HostProfile updateMany
   */
  export type HostProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update HostProfiles.
     */
    data: XOR<
      HostProfileUpdateManyMutationInput,
      HostProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which HostProfiles to update
     */
    where?: HostProfileWhereInput;
  };

  /**
   * HostProfile upsert
   */
  export type HostProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the HostProfile to update in case it exists.
     */
    where: HostProfileWhereUniqueInput;
    /**
     * In case the HostProfile found by the `where` argument doesn't exist, create a new HostProfile with this data.
     */
    create: XOR<HostProfileCreateInput, HostProfileUncheckedCreateInput>;
    /**
     * In case the HostProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HostProfileUpdateInput, HostProfileUncheckedUpdateInput>;
  };

  /**
   * HostProfile delete
   */
  export type HostProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
    /**
     * Filter which HostProfile to delete.
     */
    where: HostProfileWhereUniqueInput;
  };

  /**
   * HostProfile deleteMany
   */
  export type HostProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which HostProfiles to delete
     */
    where?: HostProfileWhereInput;
  };

  /**
   * HostProfile without action
   */
  export type HostProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the HostProfile
     */
    select?: HostProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HostProfileInclude<ExtArgs> | null;
  };

  /**
   * Model AdvertiserProfile
   */

  export type AggregateAdvertiserProfile = {
    _count: AdvertiserProfileCountAggregateOutputType | null;
    _avg: AdvertiserProfileAvgAggregateOutputType | null;
    _sum: AdvertiserProfileSumAggregateOutputType | null;
    _min: AdvertiserProfileMinAggregateOutputType | null;
    _max: AdvertiserProfileMaxAggregateOutputType | null;
  };

  export type AdvertiserProfileAvgAggregateOutputType = {
    totalSpend: number | null;
  };

  export type AdvertiserProfileSumAggregateOutputType = {
    totalSpend: number | null;
  };

  export type AdvertiserProfileMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    companyName: string | null;
    industry: string | null;
    website: string | null;
    totalSpend: number | null;
    isVerified: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AdvertiserProfileMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    companyName: string | null;
    industry: string | null;
    website: string | null;
    totalSpend: number | null;
    isVerified: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AdvertiserProfileCountAggregateOutputType = {
    id: number;
    userId: number;
    companyName: number;
    industry: number;
    website: number;
    totalSpend: number;
    isVerified: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AdvertiserProfileAvgAggregateInputType = {
    totalSpend?: true;
  };

  export type AdvertiserProfileSumAggregateInputType = {
    totalSpend?: true;
  };

  export type AdvertiserProfileMinAggregateInputType = {
    id?: true;
    userId?: true;
    companyName?: true;
    industry?: true;
    website?: true;
    totalSpend?: true;
    isVerified?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AdvertiserProfileMaxAggregateInputType = {
    id?: true;
    userId?: true;
    companyName?: true;
    industry?: true;
    website?: true;
    totalSpend?: true;
    isVerified?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AdvertiserProfileCountAggregateInputType = {
    id?: true;
    userId?: true;
    companyName?: true;
    industry?: true;
    website?: true;
    totalSpend?: true;
    isVerified?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AdvertiserProfileAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AdvertiserProfile to aggregate.
     */
    where?: AdvertiserProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdvertiserProfiles to fetch.
     */
    orderBy?:
      | AdvertiserProfileOrderByWithRelationInput
      | AdvertiserProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AdvertiserProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdvertiserProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdvertiserProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AdvertiserProfiles
     **/
    _count?: true | AdvertiserProfileCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AdvertiserProfileAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AdvertiserProfileSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AdvertiserProfileMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AdvertiserProfileMaxAggregateInputType;
  };

  export type GetAdvertiserProfileAggregateType<
    T extends AdvertiserProfileAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAdvertiserProfile]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertiserProfile[P]>
      : GetScalarType<T[P], AggregateAdvertiserProfile[P]>;
  };

  export type AdvertiserProfileGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AdvertiserProfileWhereInput;
    orderBy?:
      | AdvertiserProfileOrderByWithAggregationInput
      | AdvertiserProfileOrderByWithAggregationInput[];
    by: AdvertiserProfileScalarFieldEnum[] | AdvertiserProfileScalarFieldEnum;
    having?: AdvertiserProfileScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AdvertiserProfileCountAggregateInputType | true;
    _avg?: AdvertiserProfileAvgAggregateInputType;
    _sum?: AdvertiserProfileSumAggregateInputType;
    _min?: AdvertiserProfileMinAggregateInputType;
    _max?: AdvertiserProfileMaxAggregateInputType;
  };

  export type AdvertiserProfileGroupByOutputType = {
    id: string;
    userId: string;
    companyName: string;
    industry: string;
    website: string | null;
    totalSpend: number;
    isVerified: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: AdvertiserProfileCountAggregateOutputType | null;
    _avg: AdvertiserProfileAvgAggregateOutputType | null;
    _sum: AdvertiserProfileSumAggregateOutputType | null;
    _min: AdvertiserProfileMinAggregateOutputType | null;
    _max: AdvertiserProfileMaxAggregateOutputType | null;
  };

  type GetAdvertiserProfileGroupByPayload<
    T extends AdvertiserProfileGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertiserProfileGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof AdvertiserProfileGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AdvertiserProfileGroupByOutputType[P]>
          : GetScalarType<T[P], AdvertiserProfileGroupByOutputType[P]>;
      }
    >
  >;

  export type AdvertiserProfileSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      companyName?: boolean;
      industry?: boolean;
      website?: boolean;
      totalSpend?: boolean;
      isVerified?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['advertiserProfile']
  >;

  export type AdvertiserProfileSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      companyName?: boolean;
      industry?: boolean;
      website?: boolean;
      totalSpend?: boolean;
      isVerified?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['advertiserProfile']
  >;

  export type AdvertiserProfileSelectScalar = {
    id?: boolean;
    userId?: boolean;
    companyName?: boolean;
    industry?: boolean;
    website?: boolean;
    totalSpend?: boolean;
    isVerified?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AdvertiserProfileInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type AdvertiserProfileIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AdvertiserProfilePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AdvertiserProfile';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        companyName: string;
        industry: string;
        website: string | null;
        totalSpend: number;
        isVerified: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['advertiserProfile']
    >;
    composites: {};
  };

  type AdvertiserProfileGetPayload<
    S extends boolean | null | undefined | AdvertiserProfileDefaultArgs,
  > = $Result.GetResult<Prisma.$AdvertiserProfilePayload, S>;

  type AdvertiserProfileCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AdvertiserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: AdvertiserProfileCountAggregateInputType | true;
  };

  export interface AdvertiserProfileDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AdvertiserProfile'];
      meta: { name: 'AdvertiserProfile' };
    };
    /**
     * Find zero or one AdvertiserProfile that matches the filter.
     * @param {AdvertiserProfileFindUniqueArgs} args - Arguments to find a AdvertiserProfile
     * @example
     * // Get one AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvertiserProfileFindUniqueArgs>(
      args: SelectSubset<T, AdvertiserProfileFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one AdvertiserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdvertiserProfileFindUniqueOrThrowArgs} args - Arguments to find a AdvertiserProfile
     * @example
     * // Get one AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvertiserProfileFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AdvertiserProfileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first AdvertiserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileFindFirstArgs} args - Arguments to find a AdvertiserProfile
     * @example
     * // Get one AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvertiserProfileFindFirstArgs>(
      args?: SelectSubset<T, AdvertiserProfileFindFirstArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first AdvertiserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileFindFirstOrThrowArgs} args - Arguments to find a AdvertiserProfile
     * @example
     * // Get one AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvertiserProfileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AdvertiserProfileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more AdvertiserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvertiserProfiles
     * const advertiserProfiles = await prisma.advertiserProfile.findMany()
     *
     * // Get first 10 AdvertiserProfiles
     * const advertiserProfiles = await prisma.advertiserProfile.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const advertiserProfileWithIdOnly = await prisma.advertiserProfile.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AdvertiserProfileFindManyArgs>(
      args?: SelectSubset<T, AdvertiserProfileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'findMany'
      >
    >;

    /**
     * Create a AdvertiserProfile.
     * @param {AdvertiserProfileCreateArgs} args - Arguments to create a AdvertiserProfile.
     * @example
     * // Create one AdvertiserProfile
     * const AdvertiserProfile = await prisma.advertiserProfile.create({
     *   data: {
     *     // ... data to create a AdvertiserProfile
     *   }
     * })
     *
     */
    create<T extends AdvertiserProfileCreateArgs>(
      args: SelectSubset<T, AdvertiserProfileCreateArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<Prisma.$AdvertiserProfilePayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many AdvertiserProfiles.
     * @param {AdvertiserProfileCreateManyArgs} args - Arguments to create many AdvertiserProfiles.
     * @example
     * // Create many AdvertiserProfiles
     * const advertiserProfile = await prisma.advertiserProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AdvertiserProfileCreateManyArgs>(
      args?: SelectSubset<T, AdvertiserProfileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AdvertiserProfiles and returns the data saved in the database.
     * @param {AdvertiserProfileCreateManyAndReturnArgs} args - Arguments to create many AdvertiserProfiles.
     * @example
     * // Create many AdvertiserProfiles
     * const advertiserProfile = await prisma.advertiserProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AdvertiserProfiles and only return the `id`
     * const advertiserProfileWithIdOnly = await prisma.advertiserProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AdvertiserProfileCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AdvertiserProfileCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AdvertiserProfilePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a AdvertiserProfile.
     * @param {AdvertiserProfileDeleteArgs} args - Arguments to delete one AdvertiserProfile.
     * @example
     * // Delete one AdvertiserProfile
     * const AdvertiserProfile = await prisma.advertiserProfile.delete({
     *   where: {
     *     // ... filter to delete one AdvertiserProfile
     *   }
     * })
     *
     */
    delete<T extends AdvertiserProfileDeleteArgs>(
      args: SelectSubset<T, AdvertiserProfileDeleteArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<Prisma.$AdvertiserProfilePayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one AdvertiserProfile.
     * @param {AdvertiserProfileUpdateArgs} args - Arguments to update one AdvertiserProfile.
     * @example
     * // Update one AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AdvertiserProfileUpdateArgs>(
      args: SelectSubset<T, AdvertiserProfileUpdateArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<Prisma.$AdvertiserProfilePayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more AdvertiserProfiles.
     * @param {AdvertiserProfileDeleteManyArgs} args - Arguments to filter AdvertiserProfiles to delete.
     * @example
     * // Delete a few AdvertiserProfiles
     * const { count } = await prisma.advertiserProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AdvertiserProfileDeleteManyArgs>(
      args?: SelectSubset<T, AdvertiserProfileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AdvertiserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvertiserProfiles
     * const advertiserProfile = await prisma.advertiserProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AdvertiserProfileUpdateManyArgs>(
      args: SelectSubset<T, AdvertiserProfileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AdvertiserProfile.
     * @param {AdvertiserProfileUpsertArgs} args - Arguments to update or create a AdvertiserProfile.
     * @example
     * // Update or create a AdvertiserProfile
     * const advertiserProfile = await prisma.advertiserProfile.upsert({
     *   create: {
     *     // ... data to create a AdvertiserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvertiserProfile we want to update
     *   }
     * })
     */
    upsert<T extends AdvertiserProfileUpsertArgs>(
      args: SelectSubset<T, AdvertiserProfileUpsertArgs<ExtArgs>>
    ): Prisma__AdvertiserProfileClient<
      $Result.GetResult<Prisma.$AdvertiserProfilePayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of AdvertiserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileCountArgs} args - Arguments to filter AdvertiserProfiles to count.
     * @example
     * // Count the number of AdvertiserProfiles
     * const count = await prisma.advertiserProfile.count({
     *   where: {
     *     // ... the filter for the AdvertiserProfiles we want to count
     *   }
     * })
     **/
    count<T extends AdvertiserProfileCountArgs>(
      args?: Subset<T, AdvertiserProfileCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              AdvertiserProfileCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AdvertiserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AdvertiserProfileAggregateArgs>(
      args: Subset<T, AdvertiserProfileAggregateArgs>
    ): Prisma.PrismaPromise<GetAdvertiserProfileAggregateType<T>>;

    /**
     * Group by AdvertiserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertiserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AdvertiserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertiserProfileGroupByArgs['orderBy'] }
        : { orderBy?: AdvertiserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AdvertiserProfileGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAdvertiserProfileGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AdvertiserProfile model
     */
    readonly fields: AdvertiserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvertiserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertiserProfileClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AdvertiserProfile model
   */
  interface AdvertiserProfileFieldRefs {
    readonly id: FieldRef<'AdvertiserProfile', 'String'>;
    readonly userId: FieldRef<'AdvertiserProfile', 'String'>;
    readonly companyName: FieldRef<'AdvertiserProfile', 'String'>;
    readonly industry: FieldRef<'AdvertiserProfile', 'String'>;
    readonly website: FieldRef<'AdvertiserProfile', 'String'>;
    readonly totalSpend: FieldRef<'AdvertiserProfile', 'Float'>;
    readonly isVerified: FieldRef<'AdvertiserProfile', 'Boolean'>;
    readonly createdAt: FieldRef<'AdvertiserProfile', 'DateTime'>;
    readonly updatedAt: FieldRef<'AdvertiserProfile', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AdvertiserProfile findUnique
   */
  export type AdvertiserProfileFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter, which AdvertiserProfile to fetch.
     */
    where: AdvertiserProfileWhereUniqueInput;
  };

  /**
   * AdvertiserProfile findUniqueOrThrow
   */
  export type AdvertiserProfileFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter, which AdvertiserProfile to fetch.
     */
    where: AdvertiserProfileWhereUniqueInput;
  };

  /**
   * AdvertiserProfile findFirst
   */
  export type AdvertiserProfileFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter, which AdvertiserProfile to fetch.
     */
    where?: AdvertiserProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdvertiserProfiles to fetch.
     */
    orderBy?:
      | AdvertiserProfileOrderByWithRelationInput
      | AdvertiserProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AdvertiserProfiles.
     */
    cursor?: AdvertiserProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdvertiserProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdvertiserProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AdvertiserProfiles.
     */
    distinct?:
      | AdvertiserProfileScalarFieldEnum
      | AdvertiserProfileScalarFieldEnum[];
  };

  /**
   * AdvertiserProfile findFirstOrThrow
   */
  export type AdvertiserProfileFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter, which AdvertiserProfile to fetch.
     */
    where?: AdvertiserProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdvertiserProfiles to fetch.
     */
    orderBy?:
      | AdvertiserProfileOrderByWithRelationInput
      | AdvertiserProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AdvertiserProfiles.
     */
    cursor?: AdvertiserProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdvertiserProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdvertiserProfiles.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AdvertiserProfiles.
     */
    distinct?:
      | AdvertiserProfileScalarFieldEnum
      | AdvertiserProfileScalarFieldEnum[];
  };

  /**
   * AdvertiserProfile findMany
   */
  export type AdvertiserProfileFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter, which AdvertiserProfiles to fetch.
     */
    where?: AdvertiserProfileWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AdvertiserProfiles to fetch.
     */
    orderBy?:
      | AdvertiserProfileOrderByWithRelationInput
      | AdvertiserProfileOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AdvertiserProfiles.
     */
    cursor?: AdvertiserProfileWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AdvertiserProfiles from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AdvertiserProfiles.
     */
    skip?: number;
    distinct?:
      | AdvertiserProfileScalarFieldEnum
      | AdvertiserProfileScalarFieldEnum[];
  };

  /**
   * AdvertiserProfile create
   */
  export type AdvertiserProfileCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * The data needed to create a AdvertiserProfile.
     */
    data: XOR<
      AdvertiserProfileCreateInput,
      AdvertiserProfileUncheckedCreateInput
    >;
  };

  /**
   * AdvertiserProfile createMany
   */
  export type AdvertiserProfileCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AdvertiserProfiles.
     */
    data: AdvertiserProfileCreateManyInput | AdvertiserProfileCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AdvertiserProfile createManyAndReturn
   */
  export type AdvertiserProfileCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many AdvertiserProfiles.
     */
    data: AdvertiserProfileCreateManyInput | AdvertiserProfileCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AdvertiserProfile update
   */
  export type AdvertiserProfileUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * The data needed to update a AdvertiserProfile.
     */
    data: XOR<
      AdvertiserProfileUpdateInput,
      AdvertiserProfileUncheckedUpdateInput
    >;
    /**
     * Choose, which AdvertiserProfile to update.
     */
    where: AdvertiserProfileWhereUniqueInput;
  };

  /**
   * AdvertiserProfile updateMany
   */
  export type AdvertiserProfileUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AdvertiserProfiles.
     */
    data: XOR<
      AdvertiserProfileUpdateManyMutationInput,
      AdvertiserProfileUncheckedUpdateManyInput
    >;
    /**
     * Filter which AdvertiserProfiles to update
     */
    where?: AdvertiserProfileWhereInput;
  };

  /**
   * AdvertiserProfile upsert
   */
  export type AdvertiserProfileUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * The filter to search for the AdvertiserProfile to update in case it exists.
     */
    where: AdvertiserProfileWhereUniqueInput;
    /**
     * In case the AdvertiserProfile found by the `where` argument doesn't exist, create a new AdvertiserProfile with this data.
     */
    create: XOR<
      AdvertiserProfileCreateInput,
      AdvertiserProfileUncheckedCreateInput
    >;
    /**
     * In case the AdvertiserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AdvertiserProfileUpdateInput,
      AdvertiserProfileUncheckedUpdateInput
    >;
  };

  /**
   * AdvertiserProfile delete
   */
  export type AdvertiserProfileDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
    /**
     * Filter which AdvertiserProfile to delete.
     */
    where: AdvertiserProfileWhereUniqueInput;
  };

  /**
   * AdvertiserProfile deleteMany
   */
  export type AdvertiserProfileDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AdvertiserProfiles to delete
     */
    where?: AdvertiserProfileWhereInput;
  };

  /**
   * AdvertiserProfile without action
   */
  export type AdvertiserProfileDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AdvertiserProfile
     */
    select?: AdvertiserProfileSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertiserProfileInclude<ExtArgs> | null;
  };

  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  export type AddressMinAggregateOutputType = {
    id: string | null;
    customerProfileId: string | null;
    label: string | null;
    address: string | null;
    city: string | null;
    country: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressMaxAggregateOutputType = {
    id: string | null;
    customerProfileId: string | null;
    label: string | null;
    address: string | null;
    city: string | null;
    country: string | null;
    isDefault: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AddressCountAggregateOutputType = {
    id: number;
    customerProfileId: number;
    label: number;
    address: number;
    city: number;
    country: number;
    isDefault: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AddressMinAggregateInputType = {
    id?: true;
    customerProfileId?: true;
    label?: true;
    address?: true;
    city?: true;
    country?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressMaxAggregateInputType = {
    id?: true;
    customerProfileId?: true;
    label?: true;
    address?: true;
    city?: true;
    country?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AddressCountAggregateInputType = {
    id?: true;
    customerProfileId?: true;
    label?: true;
    address?: true;
    city?: true;
    country?: true;
    isDefault?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AddressAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Addresses
     **/
    _count?: true | AddressCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AddressMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AddressMaxAggregateInputType;
  };

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>;
  };

  export type AddressGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AddressWhereInput;
    orderBy?:
      | AddressOrderByWithAggregationInput
      | AddressOrderByWithAggregationInput[];
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum;
    having?: AddressScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AddressCountAggregateInputType | true;
    _min?: AddressMinAggregateInputType;
    _max?: AddressMaxAggregateInputType;
  };

  export type AddressGroupByOutputType = {
    id: string;
    customerProfileId: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: AddressCountAggregateOutputType | null;
    _min: AddressMinAggregateOutputType | null;
    _max: AddressMaxAggregateOutputType | null;
  };

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AddressGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AddressGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>;
        }
      >
    >;

  export type AddressSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      customerProfileId?: boolean;
      label?: boolean;
      address?: boolean;
      city?: boolean;
      country?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['address']
  >;

  export type AddressSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      customerProfileId?: boolean;
      label?: boolean;
      address?: boolean;
      city?: boolean;
      country?: boolean;
      isDefault?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['address']
  >;

  export type AddressSelectScalar = {
    id?: boolean;
    customerProfileId?: boolean;
    label?: boolean;
    address?: boolean;
    city?: boolean;
    country?: boolean;
    isDefault?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AddressInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>;
  };
  export type AddressIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    customerProfile?: boolean | CustomerProfileDefaultArgs<ExtArgs>;
  };

  export type $AddressPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Address';
    objects: {
      customerProfile: Prisma.$CustomerProfilePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        customerProfileId: string;
        label: string;
        address: string;
        city: string;
        country: string;
        isDefault: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['address']
    >;
    composites: {};
  };

  type AddressGetPayload<
    S extends boolean | null | undefined | AddressDefaultArgs,
  > = $Result.GetResult<Prisma.$AddressPayload, S>;

  type AddressCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: AddressCountAggregateInputType | true;
  };

  export interface AddressDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Address'];
      meta: { name: 'Address' };
    };
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(
      args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<
        Prisma.$AddressPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<
        Prisma.$AddressPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(
      args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirst'> | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findFirstOrThrow'>,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     *
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     *
     */
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AddressCreateManyArgs>(
      args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AddressPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     *
     */
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>
    ): Prisma__AddressClient<
      $Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
     **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AddressAggregateArgs>(
      args: Subset<T, AddressAggregateArgs>
    ): Prisma.PrismaPromise<GetAddressAggregateType<T>>;

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAddressGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Address model
     */
    readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    customerProfile<T extends CustomerProfileDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, CustomerProfileDefaultArgs<ExtArgs>>
    ): Prisma__CustomerProfileClient<
      | $Result.GetResult<
          Prisma.$CustomerProfilePayload<ExtArgs>,
          T,
          'findUniqueOrThrow'
        >
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<'Address', 'String'>;
    readonly customerProfileId: FieldRef<'Address', 'String'>;
    readonly label: FieldRef<'Address', 'String'>;
    readonly address: FieldRef<'Address', 'String'>;
    readonly city: FieldRef<'Address', 'String'>;
    readonly country: FieldRef<'Address', 'String'>;
    readonly isDefault: FieldRef<'Address', 'Boolean'>;
    readonly createdAt: FieldRef<'Address', 'DateTime'>;
    readonly updatedAt: FieldRef<'Address', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Addresses to fetch.
     */
    orderBy?:
      | AddressOrderByWithRelationInput
      | AddressOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Addresses.
     */
    skip?: number;
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[];
  };

  /**
   * Address create
   */
  export type AddressCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
  };

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Address update
   */
  export type AddressUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>;
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput;
  };

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput;
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>;
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>;
  };

  /**
   * Address delete
   */
  export type AddressDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput;
  };

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput;
  };

  /**
   * Address without action
   */
  export type AddressDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null;
  };

  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null;
    _min: RefreshTokenMinAggregateOutputType | null;
    _max: RefreshTokenMaxAggregateOutputType | null;
  };

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type RefreshTokenCountAggregateOutputType = {
    id: number;
    token: number;
    userId: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type RefreshTokenMinAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type RefreshTokenMaxAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type RefreshTokenCountAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type RefreshTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RefreshTokens
     **/
    _count?: true | RefreshTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RefreshTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RefreshTokenMaxAggregateInputType;
  };

  export type GetRefreshTokenAggregateType<
    T extends RefreshTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>;
  };

  export type RefreshTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RefreshTokenWhereInput;
    orderBy?:
      | RefreshTokenOrderByWithAggregationInput
      | RefreshTokenOrderByWithAggregationInput[];
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum;
    having?: RefreshTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RefreshTokenCountAggregateInputType | true;
    _min?: RefreshTokenMinAggregateInputType;
    _max?: RefreshTokenMaxAggregateInputType;
  };

  export type RefreshTokenGroupByOutputType = {
    id: string;
    token: string;
    userId: string;
    expiresAt: Date;
    createdAt: Date;
    _count: RefreshTokenCountAggregateOutputType | null;
    _min: RefreshTokenMinAggregateOutputType | null;
    _max: RefreshTokenMaxAggregateOutputType | null;
  };

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RefreshTokenGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof RefreshTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type RefreshTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['refreshToken']
  >;

  export type RefreshTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['refreshToken']
  >;

  export type RefreshTokenSelectScalar = {
    id?: boolean;
    token?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type RefreshTokenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type RefreshTokenIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $RefreshTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RefreshToken';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        token: string;
        userId: string;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['refreshToken']
    >;
    composites: {};
  };

  type RefreshTokenGetPayload<
    S extends boolean | null | undefined | RefreshTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$RefreshTokenPayload, S>;

  type RefreshTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: RefreshTokenCountAggregateInputType | true;
  };

  export interface RefreshTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'];
      meta: { name: 'RefreshToken' };
    };
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(
      args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(
      args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     *
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RefreshTokenFindManyArgs>(
      args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     *
     */
    create<T extends RefreshTokenCreateArgs>(
      args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RefreshTokenCreateManyArgs>(
      args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     *
     */
    delete<T extends RefreshTokenDeleteArgs>(
      args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RefreshTokenUpdateArgs>(
      args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(
      args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(
      args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(
      args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
     **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RefreshTokenAggregateArgs>(
      args: Subset<T, RefreshTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>;

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRefreshTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RefreshToken model
     */
    readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<'RefreshToken', 'String'>;
    readonly token: FieldRef<'RefreshToken', 'String'>;
    readonly userId: FieldRef<'RefreshToken', 'String'>;
    readonly expiresAt: FieldRef<'RefreshToken', 'DateTime'>;
    readonly createdAt: FieldRef<'RefreshToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>;
  };

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>;
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<
      RefreshTokenUpdateManyMutationInput,
      RefreshTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput;
  };

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput;
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>;
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>;
  };

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput;
  };

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
  };

  /**
   * Model EmailVerificationToken
   */

  export type AggregateEmailVerificationToken = {
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  export type EmailVerificationTokenMinAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type EmailVerificationTokenMaxAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type EmailVerificationTokenCountAggregateOutputType = {
    id: number;
    token: number;
    userId: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type EmailVerificationTokenMinAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type EmailVerificationTokenMaxAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type EmailVerificationTokenCountAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type EmailVerificationTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationToken to aggregate.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EmailVerificationTokens
     **/
    _count?: true | EmailVerificationTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: EmailVerificationTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type GetEmailVerificationTokenAggregateType<
    T extends EmailVerificationTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateEmailVerificationToken]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerificationToken[P]>
      : GetScalarType<T[P], AggregateEmailVerificationToken[P]>;
  };

  export type EmailVerificationTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: EmailVerificationTokenWhereInput;
    orderBy?:
      | EmailVerificationTokenOrderByWithAggregationInput
      | EmailVerificationTokenOrderByWithAggregationInput[];
    by:
      | EmailVerificationTokenScalarFieldEnum[]
      | EmailVerificationTokenScalarFieldEnum;
    having?: EmailVerificationTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: EmailVerificationTokenCountAggregateInputType | true;
    _min?: EmailVerificationTokenMinAggregateInputType;
    _max?: EmailVerificationTokenMaxAggregateInputType;
  };

  export type EmailVerificationTokenGroupByOutputType = {
    id: string;
    token: string;
    userId: string;
    expiresAt: Date;
    createdAt: Date;
    _count: EmailVerificationTokenCountAggregateOutputType | null;
    _min: EmailVerificationTokenMinAggregateOutputType | null;
    _max: EmailVerificationTokenMaxAggregateOutputType | null;
  };

  type GetEmailVerificationTokenGroupByPayload<
    T extends EmailVerificationTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationTokenGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof EmailVerificationTokenGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>
          : GetScalarType<T[P], EmailVerificationTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type EmailVerificationTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['emailVerificationToken']
  >;

  export type EmailVerificationTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['emailVerificationToken']
  >;

  export type EmailVerificationTokenSelectScalar = {
    id?: boolean;
    token?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type EmailVerificationTokenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type EmailVerificationTokenIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $EmailVerificationTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'EmailVerificationToken';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        token: string;
        userId: string;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['emailVerificationToken']
    >;
    composites: {};
  };

  type EmailVerificationTokenGetPayload<
    S extends boolean | null | undefined | EmailVerificationTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$EmailVerificationTokenPayload, S>;

  type EmailVerificationTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    EmailVerificationTokenFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: EmailVerificationTokenCountAggregateInputType | true;
  };

  export interface EmailVerificationTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['EmailVerificationToken'];
      meta: { name: 'EmailVerificationToken' };
    };
    /**
     * Find zero or one EmailVerificationToken that matches the filter.
     * @param {EmailVerificationTokenFindUniqueArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationTokenFindUniqueArgs>(
      args: SelectSubset<T, EmailVerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one EmailVerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        EmailVerificationTokenFindUniqueOrThrowArgs<ExtArgs>
      >
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationTokenFindFirstArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first EmailVerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindFirstOrThrowArgs} args - Arguments to find a EmailVerificationToken
     * @example
     * // Get one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        EmailVerificationTokenFindFirstOrThrowArgs<ExtArgs>
      >
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more EmailVerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany()
     *
     * // Get first 10 EmailVerificationTokens
     * const emailVerificationTokens = await prisma.emailVerificationToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EmailVerificationTokenFindManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'findMany'
      >
    >;

    /**
     * Create a EmailVerificationToken.
     * @param {EmailVerificationTokenCreateArgs} args - Arguments to create a EmailVerificationToken.
     * @example
     * // Create one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.create({
     *   data: {
     *     // ... data to create a EmailVerificationToken
     *   }
     * })
     *
     */
    create<T extends EmailVerificationTokenCreateArgs>(
      args: SelectSubset<T, EmailVerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'create'
      >,
      never,
      ExtArgs
    >;

    /**
     * Create many EmailVerificationTokens.
     * @param {EmailVerificationTokenCreateManyArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EmailVerificationTokenCreateManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many EmailVerificationTokens and returns the data saved in the database.
     * @param {EmailVerificationTokenCreateManyAndReturnArgs} args - Arguments to create many EmailVerificationTokens.
     * @example
     * // Create many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many EmailVerificationTokens and only return the `id`
     * const emailVerificationTokenWithIdOnly = await prisma.emailVerificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends EmailVerificationTokenCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        EmailVerificationTokenCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a EmailVerificationToken.
     * @param {EmailVerificationTokenDeleteArgs} args - Arguments to delete one EmailVerificationToken.
     * @example
     * // Delete one EmailVerificationToken
     * const EmailVerificationToken = await prisma.emailVerificationToken.delete({
     *   where: {
     *     // ... filter to delete one EmailVerificationToken
     *   }
     * })
     *
     */
    delete<T extends EmailVerificationTokenDeleteArgs>(
      args: SelectSubset<T, EmailVerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'delete'
      >,
      never,
      ExtArgs
    >;

    /**
     * Update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpdateArgs} args - Arguments to update one EmailVerificationToken.
     * @example
     * // Update one EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EmailVerificationTokenUpdateArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'update'
      >,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more EmailVerificationTokens.
     * @param {EmailVerificationTokenDeleteManyArgs} args - Arguments to filter EmailVerificationTokens to delete.
     * @example
     * // Delete a few EmailVerificationTokens
     * const { count } = await prisma.emailVerificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EmailVerificationTokenDeleteManyArgs>(
      args?: SelectSubset<T, EmailVerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerificationTokens
     * const emailVerificationToken = await prisma.emailVerificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EmailVerificationTokenUpdateManyArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one EmailVerificationToken.
     * @param {EmailVerificationTokenUpsertArgs} args - Arguments to update or create a EmailVerificationToken.
     * @example
     * // Update or create a EmailVerificationToken
     * const emailVerificationToken = await prisma.emailVerificationToken.upsert({
     *   create: {
     *     // ... data to create a EmailVerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationTokenUpsertArgs>(
      args: SelectSubset<T, EmailVerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__EmailVerificationTokenClient<
      $Result.GetResult<
        Prisma.$EmailVerificationTokenPayload<ExtArgs>,
        T,
        'upsert'
      >,
      never,
      ExtArgs
    >;

    /**
     * Count the number of EmailVerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenCountArgs} args - Arguments to filter EmailVerificationTokens to count.
     * @example
     * // Count the number of EmailVerificationTokens
     * const count = await prisma.emailVerificationToken.count({
     *   where: {
     *     // ... the filter for the EmailVerificationTokens we want to count
     *   }
     * })
     **/
    count<T extends EmailVerificationTokenCountArgs>(
      args?: Subset<T, EmailVerificationTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              EmailVerificationTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends EmailVerificationTokenAggregateArgs>(
      args: Subset<T, EmailVerificationTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetEmailVerificationTokenAggregateType<T>>;

    /**
     * Group by EmailVerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends EmailVerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        EmailVerificationTokenGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetEmailVerificationTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the EmailVerificationToken model
     */
    readonly fields: EmailVerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the EmailVerificationToken model
   */
  interface EmailVerificationTokenFieldRefs {
    readonly id: FieldRef<'EmailVerificationToken', 'String'>;
    readonly token: FieldRef<'EmailVerificationToken', 'String'>;
    readonly userId: FieldRef<'EmailVerificationToken', 'String'>;
    readonly expiresAt: FieldRef<'EmailVerificationToken', 'DateTime'>;
    readonly createdAt: FieldRef<'EmailVerificationToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * EmailVerificationToken findUnique
   */
  export type EmailVerificationTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findUniqueOrThrow
   */
  export type EmailVerificationTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken findFirst
   */
  export type EmailVerificationTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findFirstOrThrow
   */
  export type EmailVerificationTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationToken to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EmailVerificationTokens.
     */
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken findMany
   */
  export type EmailVerificationTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter, which EmailVerificationTokens to fetch.
     */
    where?: EmailVerificationTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EmailVerificationTokens to fetch.
     */
    orderBy?:
      | EmailVerificationTokenOrderByWithRelationInput
      | EmailVerificationTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EmailVerificationTokens.
     */
    cursor?: EmailVerificationTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EmailVerificationTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EmailVerificationTokens.
     */
    skip?: number;
    distinct?:
      | EmailVerificationTokenScalarFieldEnum
      | EmailVerificationTokenScalarFieldEnum[];
  };

  /**
   * EmailVerificationToken create
   */
  export type EmailVerificationTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The data needed to create a EmailVerificationToken.
     */
    data: XOR<
      EmailVerificationTokenCreateInput,
      EmailVerificationTokenUncheckedCreateInput
    >;
  };

  /**
   * EmailVerificationToken createMany
   */
  export type EmailVerificationTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data:
      | EmailVerificationTokenCreateManyInput
      | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * EmailVerificationToken createManyAndReturn
   */
  export type EmailVerificationTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many EmailVerificationTokens.
     */
    data:
      | EmailVerificationTokenCreateManyInput
      | EmailVerificationTokenCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * EmailVerificationToken update
   */
  export type EmailVerificationTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The data needed to update a EmailVerificationToken.
     */
    data: XOR<
      EmailVerificationTokenUpdateInput,
      EmailVerificationTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which EmailVerificationToken to update.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken updateMany
   */
  export type EmailVerificationTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update EmailVerificationTokens.
     */
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which EmailVerificationTokens to update
     */
    where?: EmailVerificationTokenWhereInput;
  };

  /**
   * EmailVerificationToken upsert
   */
  export type EmailVerificationTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * The filter to search for the EmailVerificationToken to update in case it exists.
     */
    where: EmailVerificationTokenWhereUniqueInput;
    /**
     * In case the EmailVerificationToken found by the `where` argument doesn't exist, create a new EmailVerificationToken with this data.
     */
    create: XOR<
      EmailVerificationTokenCreateInput,
      EmailVerificationTokenUncheckedCreateInput
    >;
    /**
     * In case the EmailVerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      EmailVerificationTokenUpdateInput,
      EmailVerificationTokenUncheckedUpdateInput
    >;
  };

  /**
   * EmailVerificationToken delete
   */
  export type EmailVerificationTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
    /**
     * Filter which EmailVerificationToken to delete.
     */
    where: EmailVerificationTokenWhereUniqueInput;
  };

  /**
   * EmailVerificationToken deleteMany
   */
  export type EmailVerificationTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which EmailVerificationTokens to delete
     */
    where?: EmailVerificationTokenWhereInput;
  };

  /**
   * EmailVerificationToken without action
   */
  export type EmailVerificationTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the EmailVerificationToken
     */
    select?: EmailVerificationTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationTokenInclude<ExtArgs> | null;
  };

  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null;
    _min: PasswordResetTokenMinAggregateOutputType | null;
    _max: PasswordResetTokenMaxAggregateOutputType | null;
  };

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number;
    token: number;
    userId: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type PasswordResetTokenMinAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type PasswordResetTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?:
      | PasswordResetTokenOrderByWithRelationInput
      | PasswordResetTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PasswordResetTokens
     **/
    _count?: true | PasswordResetTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PasswordResetTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PasswordResetTokenMaxAggregateInputType;
  };

  export type GetPasswordResetTokenAggregateType<
    T extends PasswordResetTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePasswordResetToken]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>;
  };

  export type PasswordResetTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PasswordResetTokenWhereInput;
    orderBy?:
      | PasswordResetTokenOrderByWithAggregationInput
      | PasswordResetTokenOrderByWithAggregationInput[];
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum;
    having?: PasswordResetTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PasswordResetTokenCountAggregateInputType | true;
    _min?: PasswordResetTokenMinAggregateInputType;
    _max?: PasswordResetTokenMaxAggregateInputType;
  };

  export type PasswordResetTokenGroupByOutputType = {
    id: string;
    token: string;
    userId: string;
    expiresAt: Date;
    createdAt: Date;
    _count: PasswordResetTokenCountAggregateOutputType | null;
    _min: PasswordResetTokenMinAggregateOutputType | null;
    _max: PasswordResetTokenMaxAggregateOutputType | null;
  };

  type GetPasswordResetTokenGroupByPayload<
    T extends PasswordResetTokenGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof PasswordResetTokenGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
          : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>;
      }
    >
  >;

  export type PasswordResetTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['passwordResetToken']
  >;

  export type PasswordResetTokenSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['passwordResetToken']
  >;

  export type PasswordResetTokenSelectScalar = {
    id?: boolean;
    token?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type PasswordResetTokenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PasswordResetTokenIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PasswordResetTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PasswordResetToken';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        token: string;
        userId: string;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['passwordResetToken']
    >;
    composites: {};
  };

  type PasswordResetTokenGetPayload<
    S extends boolean | null | undefined | PasswordResetTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>;

  type PasswordResetTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PasswordResetTokenFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: PasswordResetTokenCountAggregateInputType | true;
  };

  export interface PasswordResetTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'];
      meta: { name: 'PasswordResetToken' };
    };
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(
      args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(
      args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     *
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(
      args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'findMany'
      >
    >;

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     *
     */
    create<T extends PasswordResetTokenCreateArgs>(
      args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'create'
      >,
      never,
      ExtArgs
    >;

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(
      args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(
      args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     *
     */
    delete<T extends PasswordResetTokenDeleteArgs>(
      args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'delete'
      >,
      never,
      ExtArgs
    >;

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PasswordResetTokenUpdateArgs>(
      args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'update'
      >,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(
      args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(
      args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(
      args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>
    ): Prisma__PasswordResetTokenClient<
      $Result.GetResult<
        Prisma.$PasswordResetTokenPayload<ExtArgs>,
        T,
        'upsert'
      >,
      never,
      ExtArgs
    >;

    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
     **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              PasswordResetTokenCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(
      args: Subset<T, PasswordResetTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>;

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPasswordResetTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PasswordResetToken model
     */
    readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<'PasswordResetToken', 'String'>;
    readonly token: FieldRef<'PasswordResetToken', 'String'>;
    readonly userId: FieldRef<'PasswordResetToken', 'String'>;
    readonly expiresAt: FieldRef<'PasswordResetToken', 'DateTime'>;
    readonly createdAt: FieldRef<'PasswordResetToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput;
  };

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput;
  };

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?:
      | PasswordResetTokenOrderByWithRelationInput
      | PasswordResetTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?:
      | PasswordResetTokenScalarFieldEnum
      | PasswordResetTokenScalarFieldEnum[];
  };

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?:
      | PasswordResetTokenOrderByWithRelationInput
      | PasswordResetTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?:
      | PasswordResetTokenScalarFieldEnum
      | PasswordResetTokenScalarFieldEnum[];
  };

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?:
      | PasswordResetTokenOrderByWithRelationInput
      | PasswordResetTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number;
    distinct?:
      | PasswordResetTokenScalarFieldEnum
      | PasswordResetTokenScalarFieldEnum[];
  };

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<
      PasswordResetTokenCreateInput,
      PasswordResetTokenUncheckedCreateInput
    >;
  };

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data:
      | PasswordResetTokenCreateManyInput
      | PasswordResetTokenCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many PasswordResetTokens.
     */
    data:
      | PasswordResetTokenCreateManyInput
      | PasswordResetTokenCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<
      PasswordResetTokenUpdateInput,
      PasswordResetTokenUncheckedUpdateInput
    >;
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput;
  };

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<
      PasswordResetTokenUpdateManyMutationInput,
      PasswordResetTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput;
  };

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput;
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<
      PasswordResetTokenCreateInput,
      PasswordResetTokenUncheckedCreateInput
    >;
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PasswordResetTokenUpdateInput,
      PasswordResetTokenUncheckedUpdateInput
    >;
  };

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput;
  };

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput;
  };

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null;
  };

  /**
   * Model PhoneVerificationCode
   */

  export type AggregatePhoneVerificationCode = {
    _count: PhoneVerificationCodeCountAggregateOutputType | null;
    _min: PhoneVerificationCodeMinAggregateOutputType | null;
    _max: PhoneVerificationCodeMaxAggregateOutputType | null;
  };

  export type PhoneVerificationCodeMinAggregateOutputType = {
    id: string | null;
    code: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type PhoneVerificationCodeMaxAggregateOutputType = {
    id: string | null;
    code: string | null;
    userId: string | null;
    expiresAt: Date | null;
    createdAt: Date | null;
  };

  export type PhoneVerificationCodeCountAggregateOutputType = {
    id: number;
    code: number;
    userId: number;
    expiresAt: number;
    createdAt: number;
    _all: number;
  };

  export type PhoneVerificationCodeMinAggregateInputType = {
    id?: true;
    code?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type PhoneVerificationCodeMaxAggregateInputType = {
    id?: true;
    code?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
  };

  export type PhoneVerificationCodeCountAggregateInputType = {
    id?: true;
    code?: true;
    userId?: true;
    expiresAt?: true;
    createdAt?: true;
    _all?: true;
  };

  export type PhoneVerificationCodeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PhoneVerificationCode to aggregate.
     */
    where?: PhoneVerificationCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PhoneVerificationCodes to fetch.
     */
    orderBy?:
      | PhoneVerificationCodeOrderByWithRelationInput
      | PhoneVerificationCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PhoneVerificationCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PhoneVerificationCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PhoneVerificationCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PhoneVerificationCodes
     **/
    _count?: true | PhoneVerificationCodeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PhoneVerificationCodeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PhoneVerificationCodeMaxAggregateInputType;
  };

  export type GetPhoneVerificationCodeAggregateType<
    T extends PhoneVerificationCodeAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePhoneVerificationCode]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneVerificationCode[P]>
      : GetScalarType<T[P], AggregatePhoneVerificationCode[P]>;
  };

  export type PhoneVerificationCodeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PhoneVerificationCodeWhereInput;
    orderBy?:
      | PhoneVerificationCodeOrderByWithAggregationInput
      | PhoneVerificationCodeOrderByWithAggregationInput[];
    by:
      | PhoneVerificationCodeScalarFieldEnum[]
      | PhoneVerificationCodeScalarFieldEnum;
    having?: PhoneVerificationCodeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PhoneVerificationCodeCountAggregateInputType | true;
    _min?: PhoneVerificationCodeMinAggregateInputType;
    _max?: PhoneVerificationCodeMaxAggregateInputType;
  };

  export type PhoneVerificationCodeGroupByOutputType = {
    id: string;
    code: string;
    userId: string;
    expiresAt: Date;
    createdAt: Date;
    _count: PhoneVerificationCodeCountAggregateOutputType | null;
    _min: PhoneVerificationCodeMinAggregateOutputType | null;
    _max: PhoneVerificationCodeMaxAggregateOutputType | null;
  };

  type GetPhoneVerificationCodeGroupByPayload<
    T extends PhoneVerificationCodeGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhoneVerificationCodeGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof PhoneVerificationCodeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PhoneVerificationCodeGroupByOutputType[P]>
          : GetScalarType<T[P], PhoneVerificationCodeGroupByOutputType[P]>;
      }
    >
  >;

  export type PhoneVerificationCodeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['phoneVerificationCode']
  >;

  export type PhoneVerificationCodeSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      code?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['phoneVerificationCode']
  >;

  export type PhoneVerificationCodeSelectScalar = {
    id?: boolean;
    code?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
  };

  export type PhoneVerificationCodeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type PhoneVerificationCodeIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PhoneVerificationCodePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PhoneVerificationCode';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        code: string;
        userId: string;
        expiresAt: Date;
        createdAt: Date;
      },
      ExtArgs['result']['phoneVerificationCode']
    >;
    composites: {};
  };

  type PhoneVerificationCodeGetPayload<
    S extends boolean | null | undefined | PhoneVerificationCodeDefaultArgs,
  > = $Result.GetResult<Prisma.$PhoneVerificationCodePayload, S>;

  type PhoneVerificationCodeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PhoneVerificationCodeFindManyArgs,
    'select' | 'include' | 'distinct'
  > & {
    select?: PhoneVerificationCodeCountAggregateInputType | true;
  };

  export interface PhoneVerificationCodeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PhoneVerificationCode'];
      meta: { name: 'PhoneVerificationCode' };
    };
    /**
     * Find zero or one PhoneVerificationCode that matches the filter.
     * @param {PhoneVerificationCodeFindUniqueArgs} args - Arguments to find a PhoneVerificationCode
     * @example
     * // Get one PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhoneVerificationCodeFindUniqueArgs>(
      args: SelectSubset<T, PhoneVerificationCodeFindUniqueArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one PhoneVerificationCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PhoneVerificationCodeFindUniqueOrThrowArgs} args - Arguments to find a PhoneVerificationCode
     * @example
     * // Get one PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhoneVerificationCodeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PhoneVerificationCodeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first PhoneVerificationCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeFindFirstArgs} args - Arguments to find a PhoneVerificationCode
     * @example
     * // Get one PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhoneVerificationCodeFindFirstArgs>(
      args?: SelectSubset<T, PhoneVerificationCodeFindFirstArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first PhoneVerificationCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeFindFirstOrThrowArgs} args - Arguments to find a PhoneVerificationCode
     * @example
     * // Get one PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhoneVerificationCodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PhoneVerificationCodeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more PhoneVerificationCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneVerificationCodes
     * const phoneVerificationCodes = await prisma.phoneVerificationCode.findMany()
     *
     * // Get first 10 PhoneVerificationCodes
     * const phoneVerificationCodes = await prisma.phoneVerificationCode.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const phoneVerificationCodeWithIdOnly = await prisma.phoneVerificationCode.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PhoneVerificationCodeFindManyArgs>(
      args?: SelectSubset<T, PhoneVerificationCodeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'findMany'
      >
    >;

    /**
     * Create a PhoneVerificationCode.
     * @param {PhoneVerificationCodeCreateArgs} args - Arguments to create a PhoneVerificationCode.
     * @example
     * // Create one PhoneVerificationCode
     * const PhoneVerificationCode = await prisma.phoneVerificationCode.create({
     *   data: {
     *     // ... data to create a PhoneVerificationCode
     *   }
     * })
     *
     */
    create<T extends PhoneVerificationCodeCreateArgs>(
      args: SelectSubset<T, PhoneVerificationCodeCreateArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'create'
      >,
      never,
      ExtArgs
    >;

    /**
     * Create many PhoneVerificationCodes.
     * @param {PhoneVerificationCodeCreateManyArgs} args - Arguments to create many PhoneVerificationCodes.
     * @example
     * // Create many PhoneVerificationCodes
     * const phoneVerificationCode = await prisma.phoneVerificationCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PhoneVerificationCodeCreateManyArgs>(
      args?: SelectSubset<T, PhoneVerificationCodeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many PhoneVerificationCodes and returns the data saved in the database.
     * @param {PhoneVerificationCodeCreateManyAndReturnArgs} args - Arguments to create many PhoneVerificationCodes.
     * @example
     * // Create many PhoneVerificationCodes
     * const phoneVerificationCode = await prisma.phoneVerificationCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PhoneVerificationCodes and only return the `id`
     * const phoneVerificationCodeWithIdOnly = await prisma.phoneVerificationCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PhoneVerificationCodeCreateManyAndReturnArgs>(
      args?: SelectSubset<
        T,
        PhoneVerificationCodeCreateManyAndReturnArgs<ExtArgs>
      >
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a PhoneVerificationCode.
     * @param {PhoneVerificationCodeDeleteArgs} args - Arguments to delete one PhoneVerificationCode.
     * @example
     * // Delete one PhoneVerificationCode
     * const PhoneVerificationCode = await prisma.phoneVerificationCode.delete({
     *   where: {
     *     // ... filter to delete one PhoneVerificationCode
     *   }
     * })
     *
     */
    delete<T extends PhoneVerificationCodeDeleteArgs>(
      args: SelectSubset<T, PhoneVerificationCodeDeleteArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'delete'
      >,
      never,
      ExtArgs
    >;

    /**
     * Update one PhoneVerificationCode.
     * @param {PhoneVerificationCodeUpdateArgs} args - Arguments to update one PhoneVerificationCode.
     * @example
     * // Update one PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PhoneVerificationCodeUpdateArgs>(
      args: SelectSubset<T, PhoneVerificationCodeUpdateArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'update'
      >,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more PhoneVerificationCodes.
     * @param {PhoneVerificationCodeDeleteManyArgs} args - Arguments to filter PhoneVerificationCodes to delete.
     * @example
     * // Delete a few PhoneVerificationCodes
     * const { count } = await prisma.phoneVerificationCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PhoneVerificationCodeDeleteManyArgs>(
      args?: SelectSubset<T, PhoneVerificationCodeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PhoneVerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneVerificationCodes
     * const phoneVerificationCode = await prisma.phoneVerificationCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PhoneVerificationCodeUpdateManyArgs>(
      args: SelectSubset<T, PhoneVerificationCodeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PhoneVerificationCode.
     * @param {PhoneVerificationCodeUpsertArgs} args - Arguments to update or create a PhoneVerificationCode.
     * @example
     * // Update or create a PhoneVerificationCode
     * const phoneVerificationCode = await prisma.phoneVerificationCode.upsert({
     *   create: {
     *     // ... data to create a PhoneVerificationCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneVerificationCode we want to update
     *   }
     * })
     */
    upsert<T extends PhoneVerificationCodeUpsertArgs>(
      args: SelectSubset<T, PhoneVerificationCodeUpsertArgs<ExtArgs>>
    ): Prisma__PhoneVerificationCodeClient<
      $Result.GetResult<
        Prisma.$PhoneVerificationCodePayload<ExtArgs>,
        T,
        'upsert'
      >,
      never,
      ExtArgs
    >;

    /**
     * Count the number of PhoneVerificationCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeCountArgs} args - Arguments to filter PhoneVerificationCodes to count.
     * @example
     * // Count the number of PhoneVerificationCodes
     * const count = await prisma.phoneVerificationCode.count({
     *   where: {
     *     // ... the filter for the PhoneVerificationCodes we want to count
     *   }
     * })
     **/
    count<T extends PhoneVerificationCodeCountArgs>(
      args?: Subset<T, PhoneVerificationCodeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              PhoneVerificationCodeCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PhoneVerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PhoneVerificationCodeAggregateArgs>(
      args: Subset<T, PhoneVerificationCodeAggregateArgs>
    ): Prisma.PrismaPromise<GetPhoneVerificationCodeAggregateType<T>>;

    /**
     * Group by PhoneVerificationCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerificationCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PhoneVerificationCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneVerificationCodeGroupByArgs['orderBy'] }
        : { orderBy?: PhoneVerificationCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        PhoneVerificationCodeGroupByArgs,
        OrderByArg
      > &
        InputErrors
    ): {} extends InputErrors
      ? GetPhoneVerificationCodeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PhoneVerificationCode model
     */
    readonly fields: PhoneVerificationCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneVerificationCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhoneVerificationCodeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PhoneVerificationCode model
   */
  interface PhoneVerificationCodeFieldRefs {
    readonly id: FieldRef<'PhoneVerificationCode', 'String'>;
    readonly code: FieldRef<'PhoneVerificationCode', 'String'>;
    readonly userId: FieldRef<'PhoneVerificationCode', 'String'>;
    readonly expiresAt: FieldRef<'PhoneVerificationCode', 'DateTime'>;
    readonly createdAt: FieldRef<'PhoneVerificationCode', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PhoneVerificationCode findUnique
   */
  export type PhoneVerificationCodeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PhoneVerificationCode to fetch.
     */
    where: PhoneVerificationCodeWhereUniqueInput;
  };

  /**
   * PhoneVerificationCode findUniqueOrThrow
   */
  export type PhoneVerificationCodeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PhoneVerificationCode to fetch.
     */
    where: PhoneVerificationCodeWhereUniqueInput;
  };

  /**
   * PhoneVerificationCode findFirst
   */
  export type PhoneVerificationCodeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PhoneVerificationCode to fetch.
     */
    where?: PhoneVerificationCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PhoneVerificationCodes to fetch.
     */
    orderBy?:
      | PhoneVerificationCodeOrderByWithRelationInput
      | PhoneVerificationCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PhoneVerificationCodes.
     */
    cursor?: PhoneVerificationCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PhoneVerificationCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PhoneVerificationCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PhoneVerificationCodes.
     */
    distinct?:
      | PhoneVerificationCodeScalarFieldEnum
      | PhoneVerificationCodeScalarFieldEnum[];
  };

  /**
   * PhoneVerificationCode findFirstOrThrow
   */
  export type PhoneVerificationCodeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PhoneVerificationCode to fetch.
     */
    where?: PhoneVerificationCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PhoneVerificationCodes to fetch.
     */
    orderBy?:
      | PhoneVerificationCodeOrderByWithRelationInput
      | PhoneVerificationCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PhoneVerificationCodes.
     */
    cursor?: PhoneVerificationCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PhoneVerificationCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PhoneVerificationCodes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PhoneVerificationCodes.
     */
    distinct?:
      | PhoneVerificationCodeScalarFieldEnum
      | PhoneVerificationCodeScalarFieldEnum[];
  };

  /**
   * PhoneVerificationCode findMany
   */
  export type PhoneVerificationCodeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter, which PhoneVerificationCodes to fetch.
     */
    where?: PhoneVerificationCodeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PhoneVerificationCodes to fetch.
     */
    orderBy?:
      | PhoneVerificationCodeOrderByWithRelationInput
      | PhoneVerificationCodeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PhoneVerificationCodes.
     */
    cursor?: PhoneVerificationCodeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PhoneVerificationCodes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PhoneVerificationCodes.
     */
    skip?: number;
    distinct?:
      | PhoneVerificationCodeScalarFieldEnum
      | PhoneVerificationCodeScalarFieldEnum[];
  };

  /**
   * PhoneVerificationCode create
   */
  export type PhoneVerificationCodeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * The data needed to create a PhoneVerificationCode.
     */
    data: XOR<
      PhoneVerificationCodeCreateInput,
      PhoneVerificationCodeUncheckedCreateInput
    >;
  };

  /**
   * PhoneVerificationCode createMany
   */
  export type PhoneVerificationCodeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PhoneVerificationCodes.
     */
    data:
      | PhoneVerificationCodeCreateManyInput
      | PhoneVerificationCodeCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * PhoneVerificationCode createManyAndReturn
   */
  export type PhoneVerificationCodeCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many PhoneVerificationCodes.
     */
    data:
      | PhoneVerificationCodeCreateManyInput
      | PhoneVerificationCodeCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * PhoneVerificationCode update
   */
  export type PhoneVerificationCodeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * The data needed to update a PhoneVerificationCode.
     */
    data: XOR<
      PhoneVerificationCodeUpdateInput,
      PhoneVerificationCodeUncheckedUpdateInput
    >;
    /**
     * Choose, which PhoneVerificationCode to update.
     */
    where: PhoneVerificationCodeWhereUniqueInput;
  };

  /**
   * PhoneVerificationCode updateMany
   */
  export type PhoneVerificationCodeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PhoneVerificationCodes.
     */
    data: XOR<
      PhoneVerificationCodeUpdateManyMutationInput,
      PhoneVerificationCodeUncheckedUpdateManyInput
    >;
    /**
     * Filter which PhoneVerificationCodes to update
     */
    where?: PhoneVerificationCodeWhereInput;
  };

  /**
   * PhoneVerificationCode upsert
   */
  export type PhoneVerificationCodeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * The filter to search for the PhoneVerificationCode to update in case it exists.
     */
    where: PhoneVerificationCodeWhereUniqueInput;
    /**
     * In case the PhoneVerificationCode found by the `where` argument doesn't exist, create a new PhoneVerificationCode with this data.
     */
    create: XOR<
      PhoneVerificationCodeCreateInput,
      PhoneVerificationCodeUncheckedCreateInput
    >;
    /**
     * In case the PhoneVerificationCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PhoneVerificationCodeUpdateInput,
      PhoneVerificationCodeUncheckedUpdateInput
    >;
  };

  /**
   * PhoneVerificationCode delete
   */
  export type PhoneVerificationCodeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
    /**
     * Filter which PhoneVerificationCode to delete.
     */
    where: PhoneVerificationCodeWhereUniqueInput;
  };

  /**
   * PhoneVerificationCode deleteMany
   */
  export type PhoneVerificationCodeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PhoneVerificationCodes to delete
     */
    where?: PhoneVerificationCodeWhereInput;
  };

  /**
   * PhoneVerificationCode without action
   */
  export type PhoneVerificationCodeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PhoneVerificationCode
     */
    select?: PhoneVerificationCodeSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhoneVerificationCodeInclude<ExtArgs> | null;
  };

  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  export type AuditLogMinAggregateOutputType = {
    id: string | null;
    action: string | null;
    adminUserId: string | null;
    targetUserId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogMaxAggregateOutputType = {
    id: string | null;
    action: string | null;
    adminUserId: string | null;
    targetUserId: string | null;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date | null;
  };

  export type AuditLogCountAggregateOutputType = {
    id: number;
    action: number;
    adminUserId: number;
    targetUserId: number;
    details: number;
    ipAddress: number;
    userAgent: number;
    createdAt: number;
    _all: number;
  };

  export type AuditLogMinAggregateInputType = {
    id?: true;
    action?: true;
    adminUserId?: true;
    targetUserId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogMaxAggregateInputType = {
    id?: true;
    action?: true;
    adminUserId?: true;
    targetUserId?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
  };

  export type AuditLogCountAggregateInputType = {
    id?: true;
    action?: true;
    adminUserId?: true;
    targetUserId?: true;
    details?: true;
    ipAddress?: true;
    userAgent?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AuditLogAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AuditLogs
     **/
    _count?: true | AuditLogCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AuditLogMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AuditLogMaxAggregateInputType;
  };

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
    [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>;
  };

  export type AuditLogGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AuditLogWhereInput;
    orderBy?:
      | AuditLogOrderByWithAggregationInput
      | AuditLogOrderByWithAggregationInput[];
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum;
    having?: AuditLogScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AuditLogCountAggregateInputType | true;
    _min?: AuditLogMinAggregateInputType;
    _max?: AuditLogMaxAggregateInputType;
  };

  export type AuditLogGroupByOutputType = {
    id: string;
    action: string;
    adminUserId: string;
    targetUserId: string | null;
    details: JsonValue;
    ipAddress: string | null;
    userAgent: string | null;
    createdAt: Date;
    _count: AuditLogCountAggregateOutputType | null;
    _min: AuditLogMinAggregateOutputType | null;
    _max: AuditLogMaxAggregateOutputType | null;
  };

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AuditLogGroupByOutputType, T['by']> & {
          [P in keyof T & keyof AuditLogGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>;
        }
      >
    >;

  export type AuditLogSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      adminUserId?: boolean;
      targetUserId?: boolean;
      details?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      adminUser?: boolean | UserDefaultArgs<ExtArgs>;
      targetUser?: boolean | AuditLog$targetUserArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      action?: boolean;
      adminUserId?: boolean;
      targetUserId?: boolean;
      details?: boolean;
      ipAddress?: boolean;
      userAgent?: boolean;
      createdAt?: boolean;
      adminUser?: boolean | UserDefaultArgs<ExtArgs>;
      targetUser?: boolean | AuditLog$targetUserArgs<ExtArgs>;
    },
    ExtArgs['result']['auditLog']
  >;

  export type AuditLogSelectScalar = {
    id?: boolean;
    action?: boolean;
    adminUserId?: boolean;
    targetUserId?: boolean;
    details?: boolean;
    ipAddress?: boolean;
    userAgent?: boolean;
    createdAt?: boolean;
  };

  export type AuditLogInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    adminUser?: boolean | UserDefaultArgs<ExtArgs>;
    targetUser?: boolean | AuditLog$targetUserArgs<ExtArgs>;
  };
  export type AuditLogIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    adminUser?: boolean | UserDefaultArgs<ExtArgs>;
    targetUser?: boolean | AuditLog$targetUserArgs<ExtArgs>;
  };

  export type $AuditLogPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AuditLog';
    objects: {
      adminUser: Prisma.$UserPayload<ExtArgs>;
      targetUser: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        action: string;
        adminUserId: string;
        targetUserId: string | null;
        details: Prisma.JsonValue;
        ipAddress: string | null;
        userAgent: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['auditLog']
    >;
    composites: {};
  };

  type AuditLogGetPayload<
    S extends boolean | null | undefined | AuditLogDefaultArgs,
  > = $Result.GetResult<Prisma.$AuditLogPayload, S>;

  type AuditLogCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
    select?: AuditLogCountAggregateInputType | true;
  };

  export interface AuditLogDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'];
      meta: { name: 'AuditLog' };
    };
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(
      args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUnique'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(
      args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirst'
      > | null,
      null,
      ExtArgs
    >;

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'findFirstOrThrow'
      >,
      never,
      ExtArgs
    >;

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     *
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AuditLogFindManyArgs>(
      args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'findMany'>
    >;

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     *
     */
    create<T extends AuditLogCreateArgs>(
      args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'create'>,
      never,
      ExtArgs
    >;

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AuditLogCreateManyArgs>(
      args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AuditLogPayload<ExtArgs>,
        T,
        'createManyAndReturn'
      >
    >;

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     *
     */
    delete<T extends AuditLogDeleteArgs>(
      args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'delete'>,
      never,
      ExtArgs
    >;

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AuditLogUpdateArgs>(
      args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'update'>,
      never,
      ExtArgs
    >;

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(
      args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AuditLogUpdateManyArgs>(
      args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(
      args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>
    ): Prisma__AuditLogClient<
      $Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, 'upsert'>,
      never,
      ExtArgs
    >;

    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
     **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AuditLogAggregateArgs>(
      args: Subset<T, AuditLogAggregateArgs>
    ): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>;

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetAuditLogGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AuditLog model
     */
    readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    adminUser<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>
      | Null,
      Null,
      ExtArgs
    >;
    targetUser<T extends AuditLog$targetUserArgs<ExtArgs> = {}>(
      args?: Subset<T, AuditLog$targetUserArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow'
      > | null,
      null,
      ExtArgs
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<'AuditLog', 'String'>;
    readonly action: FieldRef<'AuditLog', 'String'>;
    readonly adminUserId: FieldRef<'AuditLog', 'String'>;
    readonly targetUserId: FieldRef<'AuditLog', 'String'>;
    readonly details: FieldRef<'AuditLog', 'Json'>;
    readonly ipAddress: FieldRef<'AuditLog', 'String'>;
    readonly userAgent: FieldRef<'AuditLog', 'String'>;
    readonly createdAt: FieldRef<'AuditLog', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?:
      | AuditLogOrderByWithRelationInput
      | AuditLogOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AuditLogs.
     */
    skip?: number;
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[];
  };

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
  };

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyInput
    >;
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput;
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>;
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>;
  };

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput;
  };

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput;
  };

  /**
   * AuditLog.targetUser
   */
  export type AuditLog$targetUserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    phone: 'phone';
    passwordHash: 'passwordHash';
    firstName: 'firstName';
    lastName: 'lastName';
    avatar: 'avatar';
    isEmailVerified: 'isEmailVerified';
    isPhoneVerified: 'isPhoneVerified';
    isActive: 'isActive';
    lastLoginAt: 'lastLoginAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    activeRole: 'activeRole';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const RoleScalarFieldEnum: {
    id: 'id';
    name: 'name';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RoleScalarFieldEnum =
    (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

  export const PermissionScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    createdAt: 'createdAt';
  };

  export type PermissionScalarFieldEnum =
    (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum];

  export const UserRoleScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    roleId: 'roleId';
    assignedAt: 'assignedAt';
  };

  export type UserRoleScalarFieldEnum =
    (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum];

  export const CustomerProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    preferences: 'preferences';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type CustomerProfileScalarFieldEnum =
    (typeof CustomerProfileScalarFieldEnum)[keyof typeof CustomerProfileScalarFieldEnum];

  export const VendorProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    businessName: 'businessName';
    businessType: 'businessType';
    description: 'description';
    logo: 'logo';
    website: 'website';
    subscriptionTier: 'subscriptionTier';
    commissionRate: 'commissionRate';
    isVerified: 'isVerified';
    rating: 'rating';
    totalSales: 'totalSales';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type VendorProfileScalarFieldEnum =
    (typeof VendorProfileScalarFieldEnum)[keyof typeof VendorProfileScalarFieldEnum];

  export const DriverProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    licenseNumber: 'licenseNumber';
    vehicleInfo: 'vehicleInfo';
    isOnline: 'isOnline';
    currentLocation: 'currentLocation';
    rating: 'rating';
    totalRides: 'totalRides';
    isVerified: 'isVerified';
    subscriptionTier: 'subscriptionTier';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type DriverProfileScalarFieldEnum =
    (typeof DriverProfileScalarFieldEnum)[keyof typeof DriverProfileScalarFieldEnum];

  export const HostProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    businessName: 'businessName';
    description: 'description';
    rating: 'rating';
    totalBookings: 'totalBookings';
    isVerified: 'isVerified';
    subscriptionTier: 'subscriptionTier';
    responseRate: 'responseRate';
    responseTime: 'responseTime';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type HostProfileScalarFieldEnum =
    (typeof HostProfileScalarFieldEnum)[keyof typeof HostProfileScalarFieldEnum];

  export const AdvertiserProfileScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    companyName: 'companyName';
    industry: 'industry';
    website: 'website';
    totalSpend: 'totalSpend';
    isVerified: 'isVerified';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AdvertiserProfileScalarFieldEnum =
    (typeof AdvertiserProfileScalarFieldEnum)[keyof typeof AdvertiserProfileScalarFieldEnum];

  export const AddressScalarFieldEnum: {
    id: 'id';
    customerProfileId: 'customerProfileId';
    label: 'label';
    address: 'address';
    city: 'city';
    country: 'country';
    isDefault: 'isDefault';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AddressScalarFieldEnum =
    (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum];

  export const RefreshTokenScalarFieldEnum: {
    id: 'id';
    token: 'token';
    userId: 'userId';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type RefreshTokenScalarFieldEnum =
    (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum];

  export const EmailVerificationTokenScalarFieldEnum: {
    id: 'id';
    token: 'token';
    userId: 'userId';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type EmailVerificationTokenScalarFieldEnum =
    (typeof EmailVerificationTokenScalarFieldEnum)[keyof typeof EmailVerificationTokenScalarFieldEnum];

  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id';
    token: 'token';
    userId: 'userId';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type PasswordResetTokenScalarFieldEnum =
    (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum];

  export const PhoneVerificationCodeScalarFieldEnum: {
    id: 'id';
    code: 'code';
    userId: 'userId';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
  };

  export type PhoneVerificationCodeScalarFieldEnum =
    (typeof PhoneVerificationCodeScalarFieldEnum)[keyof typeof PhoneVerificationCodeScalarFieldEnum];

  export const AuditLogScalarFieldEnum: {
    id: 'id';
    action: 'action';
    adminUserId: 'adminUserId';
    targetUserId: 'targetUserId';
    details: 'details';
    ipAddress: 'ipAddress';
    userAgent: 'userAgent';
    createdAt: 'createdAt';
  };

  export type AuditLogScalarFieldEnum =
    (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
  };

  export type NullableJsonNullValueInput =
    (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RoleName'
  >;

  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'RoleName[]'
  >;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'SubscriptionTier'>;

  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'DriverTier'
   */
  export type EnumDriverTierFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DriverTier'
  >;

  /**
   * Reference to a field of type 'DriverTier[]'
   */
  export type ListEnumDriverTierFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DriverTier[]'
  >;

  /**
   * Reference to a field of type 'HostTier'
   */
  export type EnumHostTierFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HostTier'
  >;

  /**
   * Reference to a field of type 'HostTier[]'
   */
  export type ListEnumHostTierFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'HostTier[]'
  >;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    phone?: StringNullableFilter<'User'> | string | null;
    passwordHash?: StringFilter<'User'> | string;
    firstName?: StringFilter<'User'> | string;
    lastName?: StringFilter<'User'> | string;
    avatar?: StringNullableFilter<'User'> | string | null;
    isEmailVerified?: BoolFilter<'User'> | boolean;
    isPhoneVerified?: BoolFilter<'User'> | boolean;
    isActive?: BoolFilter<'User'> | boolean;
    lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    activeRole?: EnumRoleNameFilter<'User'> | $Enums.RoleName;
    roles?: UserRoleListRelationFilter;
    customerProfile?: XOR<
      CustomerProfileNullableRelationFilter,
      CustomerProfileWhereInput
    > | null;
    vendorProfile?: XOR<
      VendorProfileNullableRelationFilter,
      VendorProfileWhereInput
    > | null;
    driverProfile?: XOR<
      DriverProfileNullableRelationFilter,
      DriverProfileWhereInput
    > | null;
    hostProfile?: XOR<
      HostProfileNullableRelationFilter,
      HostProfileWhereInput
    > | null;
    advertiserProfile?: XOR<
      AdvertiserProfileNullableRelationFilter,
      AdvertiserProfileWhereInput
    > | null;
    refreshTokens?: RefreshTokenListRelationFilter;
    emailVerificationTokens?: EmailVerificationTokenListRelationFilter;
    passwordResetTokens?: PasswordResetTokenListRelationFilter;
    phoneVerificationCodes?: PhoneVerificationCodeListRelationFilter;
    adminAuditLogs?: AuditLogListRelationFilter;
    targetAuditLogs?: AuditLogListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatar?: SortOrderInput | SortOrder;
    isEmailVerified?: SortOrder;
    isPhoneVerified?: SortOrder;
    isActive?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    activeRole?: SortOrder;
    roles?: UserRoleOrderByRelationAggregateInput;
    customerProfile?: CustomerProfileOrderByWithRelationInput;
    vendorProfile?: VendorProfileOrderByWithRelationInput;
    driverProfile?: DriverProfileOrderByWithRelationInput;
    hostProfile?: HostProfileOrderByWithRelationInput;
    advertiserProfile?: AdvertiserProfileOrderByWithRelationInput;
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput;
    emailVerificationTokens?: EmailVerificationTokenOrderByRelationAggregateInput;
    passwordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput;
    phoneVerificationCodes?: PhoneVerificationCodeOrderByRelationAggregateInput;
    adminAuditLogs?: AuditLogOrderByRelationAggregateInput;
    targetAuditLogs?: AuditLogOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      phone?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      passwordHash?: StringFilter<'User'> | string;
      firstName?: StringFilter<'User'> | string;
      lastName?: StringFilter<'User'> | string;
      avatar?: StringNullableFilter<'User'> | string | null;
      isEmailVerified?: BoolFilter<'User'> | boolean;
      isPhoneVerified?: BoolFilter<'User'> | boolean;
      isActive?: BoolFilter<'User'> | boolean;
      lastLoginAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      activeRole?: EnumRoleNameFilter<'User'> | $Enums.RoleName;
      roles?: UserRoleListRelationFilter;
      customerProfile?: XOR<
        CustomerProfileNullableRelationFilter,
        CustomerProfileWhereInput
      > | null;
      vendorProfile?: XOR<
        VendorProfileNullableRelationFilter,
        VendorProfileWhereInput
      > | null;
      driverProfile?: XOR<
        DriverProfileNullableRelationFilter,
        DriverProfileWhereInput
      > | null;
      hostProfile?: XOR<
        HostProfileNullableRelationFilter,
        HostProfileWhereInput
      > | null;
      advertiserProfile?: XOR<
        AdvertiserProfileNullableRelationFilter,
        AdvertiserProfileWhereInput
      > | null;
      refreshTokens?: RefreshTokenListRelationFilter;
      emailVerificationTokens?: EmailVerificationTokenListRelationFilter;
      passwordResetTokens?: PasswordResetTokenListRelationFilter;
      phoneVerificationCodes?: PhoneVerificationCodeListRelationFilter;
      adminAuditLogs?: AuditLogListRelationFilter;
      targetAuditLogs?: AuditLogListRelationFilter;
    },
    'id' | 'email' | 'phone'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrderInput | SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatar?: SortOrderInput | SortOrder;
    isEmailVerified?: SortOrder;
    isPhoneVerified?: SortOrder;
    isActive?: SortOrder;
    lastLoginAt?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    activeRole?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    passwordHash?: StringWithAggregatesFilter<'User'> | string;
    firstName?: StringWithAggregatesFilter<'User'> | string;
    lastName?: StringWithAggregatesFilter<'User'> | string;
    avatar?: StringNullableWithAggregatesFilter<'User'> | string | null;
    isEmailVerified?: BoolWithAggregatesFilter<'User'> | boolean;
    isPhoneVerified?: BoolWithAggregatesFilter<'User'> | boolean;
    isActive?: BoolWithAggregatesFilter<'User'> | boolean;
    lastLoginAt?:
      | DateTimeNullableWithAggregatesFilter<'User'>
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    activeRole?: EnumRoleNameWithAggregatesFilter<'User'> | $Enums.RoleName;
  };

  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[];
    OR?: RoleWhereInput[];
    NOT?: RoleWhereInput | RoleWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: EnumRoleNameFilter<'Role'> | $Enums.RoleName;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
    permissions?: PermissionListRelationFilter;
    users?: UserRoleListRelationFilter;
  };

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    permissions?: PermissionOrderByRelationAggregateInput;
    users?: UserRoleOrderByRelationAggregateInput;
  };

  export type RoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: $Enums.RoleName;
      AND?: RoleWhereInput | RoleWhereInput[];
      OR?: RoleWhereInput[];
      NOT?: RoleWhereInput | RoleWhereInput[];
      createdAt?: DateTimeFilter<'Role'> | Date | string;
      updatedAt?: DateTimeFilter<'Role'> | Date | string;
      permissions?: PermissionListRelationFilter;
      users?: UserRoleListRelationFilter;
    },
    'id' | 'name'
  >;

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RoleCountOrderByAggregateInput;
    _max?: RoleMaxOrderByAggregateInput;
    _min?: RoleMinOrderByAggregateInput;
  };

  export type RoleScalarWhereWithAggregatesInput = {
    AND?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    OR?: RoleScalarWhereWithAggregatesInput[];
    NOT?:
      | RoleScalarWhereWithAggregatesInput
      | RoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Role'> | string;
    name?: EnumRoleNameWithAggregatesFilter<'Role'> | $Enums.RoleName;
    createdAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Role'> | Date | string;
  };

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[];
    OR?: PermissionWhereInput[];
    NOT?: PermissionWhereInput | PermissionWhereInput[];
    id?: StringFilter<'Permission'> | string;
    name?: StringFilter<'Permission'> | string;
    description?: StringNullableFilter<'Permission'> | string | null;
    createdAt?: DateTimeFilter<'Permission'> | Date | string;
    roles?: RoleListRelationFilter;
  };

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    roles?: RoleOrderByRelationAggregateInput;
  };

  export type PermissionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      name?: string;
      AND?: PermissionWhereInput | PermissionWhereInput[];
      OR?: PermissionWhereInput[];
      NOT?: PermissionWhereInput | PermissionWhereInput[];
      description?: StringNullableFilter<'Permission'> | string | null;
      createdAt?: DateTimeFilter<'Permission'> | Date | string;
      roles?: RoleListRelationFilter;
    },
    'id' | 'name'
  >;

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: PermissionCountOrderByAggregateInput;
    _max?: PermissionMaxOrderByAggregateInput;
    _min?: PermissionMinOrderByAggregateInput;
  };

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?:
      | PermissionScalarWhereWithAggregatesInput
      | PermissionScalarWhereWithAggregatesInput[];
    OR?: PermissionScalarWhereWithAggregatesInput[];
    NOT?:
      | PermissionScalarWhereWithAggregatesInput
      | PermissionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Permission'> | string;
    name?: StringWithAggregatesFilter<'Permission'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'Permission'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'Permission'> | Date | string;
  };

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[];
    OR?: UserRoleWhereInput[];
    NOT?: UserRoleWhereInput | UserRoleWhereInput[];
    id?: StringFilter<'UserRole'> | string;
    userId?: StringFilter<'UserRole'> | string;
    roleId?: StringFilter<'UserRole'> | string;
    assignedAt?: DateTimeFilter<'UserRole'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
    role?: XOR<RoleRelationFilter, RoleWhereInput>;
  };

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    assignedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    role?: RoleOrderByWithRelationInput;
  };

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput;
      AND?: UserRoleWhereInput | UserRoleWhereInput[];
      OR?: UserRoleWhereInput[];
      NOT?: UserRoleWhereInput | UserRoleWhereInput[];
      userId?: StringFilter<'UserRole'> | string;
      roleId?: StringFilter<'UserRole'> | string;
      assignedAt?: DateTimeFilter<'UserRole'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
      role?: XOR<RoleRelationFilter, RoleWhereInput>;
    },
    'id' | 'userId_roleId'
  >;

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    assignedAt?: SortOrder;
    _count?: UserRoleCountOrderByAggregateInput;
    _max?: UserRoleMaxOrderByAggregateInput;
    _min?: UserRoleMinOrderByAggregateInput;
  };

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?:
      | UserRoleScalarWhereWithAggregatesInput
      | UserRoleScalarWhereWithAggregatesInput[];
    OR?: UserRoleScalarWhereWithAggregatesInput[];
    NOT?:
      | UserRoleScalarWhereWithAggregatesInput
      | UserRoleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'UserRole'> | string;
    userId?: StringWithAggregatesFilter<'UserRole'> | string;
    roleId?: StringWithAggregatesFilter<'UserRole'> | string;
    assignedAt?: DateTimeWithAggregatesFilter<'UserRole'> | Date | string;
  };

  export type CustomerProfileWhereInput = {
    AND?: CustomerProfileWhereInput | CustomerProfileWhereInput[];
    OR?: CustomerProfileWhereInput[];
    NOT?: CustomerProfileWhereInput | CustomerProfileWhereInput[];
    id?: StringFilter<'CustomerProfile'> | string;
    userId?: StringFilter<'CustomerProfile'> | string;
    preferences?: JsonNullableFilter<'CustomerProfile'>;
    createdAt?: DateTimeFilter<'CustomerProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'CustomerProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
    addresses?: AddressListRelationFilter;
  };

  export type CustomerProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    preferences?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    addresses?: AddressOrderByRelationAggregateInput;
  };

  export type CustomerProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: CustomerProfileWhereInput | CustomerProfileWhereInput[];
      OR?: CustomerProfileWhereInput[];
      NOT?: CustomerProfileWhereInput | CustomerProfileWhereInput[];
      preferences?: JsonNullableFilter<'CustomerProfile'>;
      createdAt?: DateTimeFilter<'CustomerProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'CustomerProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
      addresses?: AddressListRelationFilter;
    },
    'id' | 'userId'
  >;

  export type CustomerProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    preferences?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CustomerProfileCountOrderByAggregateInput;
    _max?: CustomerProfileMaxOrderByAggregateInput;
    _min?: CustomerProfileMinOrderByAggregateInput;
  };

  export type CustomerProfileScalarWhereWithAggregatesInput = {
    AND?:
      | CustomerProfileScalarWhereWithAggregatesInput
      | CustomerProfileScalarWhereWithAggregatesInput[];
    OR?: CustomerProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | CustomerProfileScalarWhereWithAggregatesInput
      | CustomerProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'CustomerProfile'> | string;
    userId?: StringWithAggregatesFilter<'CustomerProfile'> | string;
    preferences?: JsonNullableWithAggregatesFilter<'CustomerProfile'>;
    createdAt?: DateTimeWithAggregatesFilter<'CustomerProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'CustomerProfile'> | Date | string;
  };

  export type VendorProfileWhereInput = {
    AND?: VendorProfileWhereInput | VendorProfileWhereInput[];
    OR?: VendorProfileWhereInput[];
    NOT?: VendorProfileWhereInput | VendorProfileWhereInput[];
    id?: StringFilter<'VendorProfile'> | string;
    userId?: StringFilter<'VendorProfile'> | string;
    businessName?: StringFilter<'VendorProfile'> | string;
    businessType?: StringFilter<'VendorProfile'> | string;
    description?: StringNullableFilter<'VendorProfile'> | string | null;
    logo?: StringNullableFilter<'VendorProfile'> | string | null;
    website?: StringNullableFilter<'VendorProfile'> | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFilter<'VendorProfile'>
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFilter<'VendorProfile'> | number;
    isVerified?: BoolFilter<'VendorProfile'> | boolean;
    rating?: FloatNullableFilter<'VendorProfile'> | number | null;
    totalSales?: FloatFilter<'VendorProfile'> | number;
    createdAt?: DateTimeFilter<'VendorProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'VendorProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type VendorProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    businessType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    logo?: SortOrderInput | SortOrder;
    website?: SortOrderInput | SortOrder;
    subscriptionTier?: SortOrder;
    commissionRate?: SortOrder;
    isVerified?: SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalSales?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type VendorProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: VendorProfileWhereInput | VendorProfileWhereInput[];
      OR?: VendorProfileWhereInput[];
      NOT?: VendorProfileWhereInput | VendorProfileWhereInput[];
      businessName?: StringFilter<'VendorProfile'> | string;
      businessType?: StringFilter<'VendorProfile'> | string;
      description?: StringNullableFilter<'VendorProfile'> | string | null;
      logo?: StringNullableFilter<'VendorProfile'> | string | null;
      website?: StringNullableFilter<'VendorProfile'> | string | null;
      subscriptionTier?:
        | EnumSubscriptionTierFilter<'VendorProfile'>
        | $Enums.SubscriptionTier;
      commissionRate?: FloatFilter<'VendorProfile'> | number;
      isVerified?: BoolFilter<'VendorProfile'> | boolean;
      rating?: FloatNullableFilter<'VendorProfile'> | number | null;
      totalSales?: FloatFilter<'VendorProfile'> | number;
      createdAt?: DateTimeFilter<'VendorProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'VendorProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'userId'
  >;

  export type VendorProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    businessType?: SortOrder;
    description?: SortOrderInput | SortOrder;
    logo?: SortOrderInput | SortOrder;
    website?: SortOrderInput | SortOrder;
    subscriptionTier?: SortOrder;
    commissionRate?: SortOrder;
    isVerified?: SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalSales?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: VendorProfileCountOrderByAggregateInput;
    _avg?: VendorProfileAvgOrderByAggregateInput;
    _max?: VendorProfileMaxOrderByAggregateInput;
    _min?: VendorProfileMinOrderByAggregateInput;
    _sum?: VendorProfileSumOrderByAggregateInput;
  };

  export type VendorProfileScalarWhereWithAggregatesInput = {
    AND?:
      | VendorProfileScalarWhereWithAggregatesInput
      | VendorProfileScalarWhereWithAggregatesInput[];
    OR?: VendorProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | VendorProfileScalarWhereWithAggregatesInput
      | VendorProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'VendorProfile'> | string;
    userId?: StringWithAggregatesFilter<'VendorProfile'> | string;
    businessName?: StringWithAggregatesFilter<'VendorProfile'> | string;
    businessType?: StringWithAggregatesFilter<'VendorProfile'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'VendorProfile'>
      | string
      | null;
    logo?: StringNullableWithAggregatesFilter<'VendorProfile'> | string | null;
    website?:
      | StringNullableWithAggregatesFilter<'VendorProfile'>
      | string
      | null;
    subscriptionTier?:
      | EnumSubscriptionTierWithAggregatesFilter<'VendorProfile'>
      | $Enums.SubscriptionTier;
    commissionRate?: FloatWithAggregatesFilter<'VendorProfile'> | number;
    isVerified?: BoolWithAggregatesFilter<'VendorProfile'> | boolean;
    rating?: FloatNullableWithAggregatesFilter<'VendorProfile'> | number | null;
    totalSales?: FloatWithAggregatesFilter<'VendorProfile'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'VendorProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'VendorProfile'> | Date | string;
  };

  export type DriverProfileWhereInput = {
    AND?: DriverProfileWhereInput | DriverProfileWhereInput[];
    OR?: DriverProfileWhereInput[];
    NOT?: DriverProfileWhereInput | DriverProfileWhereInput[];
    id?: StringFilter<'DriverProfile'> | string;
    userId?: StringFilter<'DriverProfile'> | string;
    licenseNumber?: StringFilter<'DriverProfile'> | string;
    vehicleInfo?: JsonFilter<'DriverProfile'>;
    isOnline?: BoolFilter<'DriverProfile'> | boolean;
    currentLocation?: JsonNullableFilter<'DriverProfile'>;
    rating?: FloatNullableFilter<'DriverProfile'> | number | null;
    totalRides?: IntFilter<'DriverProfile'> | number;
    isVerified?: BoolFilter<'DriverProfile'> | boolean;
    subscriptionTier?:
      | EnumDriverTierFilter<'DriverProfile'>
      | $Enums.DriverTier;
    createdAt?: DateTimeFilter<'DriverProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'DriverProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type DriverProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    licenseNumber?: SortOrder;
    vehicleInfo?: SortOrder;
    isOnline?: SortOrder;
    currentLocation?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalRides?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type DriverProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      licenseNumber?: string;
      AND?: DriverProfileWhereInput | DriverProfileWhereInput[];
      OR?: DriverProfileWhereInput[];
      NOT?: DriverProfileWhereInput | DriverProfileWhereInput[];
      vehicleInfo?: JsonFilter<'DriverProfile'>;
      isOnline?: BoolFilter<'DriverProfile'> | boolean;
      currentLocation?: JsonNullableFilter<'DriverProfile'>;
      rating?: FloatNullableFilter<'DriverProfile'> | number | null;
      totalRides?: IntFilter<'DriverProfile'> | number;
      isVerified?: BoolFilter<'DriverProfile'> | boolean;
      subscriptionTier?:
        | EnumDriverTierFilter<'DriverProfile'>
        | $Enums.DriverTier;
      createdAt?: DateTimeFilter<'DriverProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'DriverProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'userId' | 'licenseNumber'
  >;

  export type DriverProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    licenseNumber?: SortOrder;
    vehicleInfo?: SortOrder;
    isOnline?: SortOrder;
    currentLocation?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalRides?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: DriverProfileCountOrderByAggregateInput;
    _avg?: DriverProfileAvgOrderByAggregateInput;
    _max?: DriverProfileMaxOrderByAggregateInput;
    _min?: DriverProfileMinOrderByAggregateInput;
    _sum?: DriverProfileSumOrderByAggregateInput;
  };

  export type DriverProfileScalarWhereWithAggregatesInput = {
    AND?:
      | DriverProfileScalarWhereWithAggregatesInput
      | DriverProfileScalarWhereWithAggregatesInput[];
    OR?: DriverProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | DriverProfileScalarWhereWithAggregatesInput
      | DriverProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'DriverProfile'> | string;
    userId?: StringWithAggregatesFilter<'DriverProfile'> | string;
    licenseNumber?: StringWithAggregatesFilter<'DriverProfile'> | string;
    vehicleInfo?: JsonWithAggregatesFilter<'DriverProfile'>;
    isOnline?: BoolWithAggregatesFilter<'DriverProfile'> | boolean;
    currentLocation?: JsonNullableWithAggregatesFilter<'DriverProfile'>;
    rating?: FloatNullableWithAggregatesFilter<'DriverProfile'> | number | null;
    totalRides?: IntWithAggregatesFilter<'DriverProfile'> | number;
    isVerified?: BoolWithAggregatesFilter<'DriverProfile'> | boolean;
    subscriptionTier?:
      | EnumDriverTierWithAggregatesFilter<'DriverProfile'>
      | $Enums.DriverTier;
    createdAt?: DateTimeWithAggregatesFilter<'DriverProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'DriverProfile'> | Date | string;
  };

  export type HostProfileWhereInput = {
    AND?: HostProfileWhereInput | HostProfileWhereInput[];
    OR?: HostProfileWhereInput[];
    NOT?: HostProfileWhereInput | HostProfileWhereInput[];
    id?: StringFilter<'HostProfile'> | string;
    userId?: StringFilter<'HostProfile'> | string;
    businessName?: StringNullableFilter<'HostProfile'> | string | null;
    description?: StringNullableFilter<'HostProfile'> | string | null;
    rating?: FloatNullableFilter<'HostProfile'> | number | null;
    totalBookings?: IntFilter<'HostProfile'> | number;
    isVerified?: BoolFilter<'HostProfile'> | boolean;
    subscriptionTier?: EnumHostTierFilter<'HostProfile'> | $Enums.HostTier;
    responseRate?: FloatNullableFilter<'HostProfile'> | number | null;
    responseTime?: IntNullableFilter<'HostProfile'> | number | null;
    createdAt?: DateTimeFilter<'HostProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'HostProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type HostProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalBookings?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    responseRate?: SortOrderInput | SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type HostProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: HostProfileWhereInput | HostProfileWhereInput[];
      OR?: HostProfileWhereInput[];
      NOT?: HostProfileWhereInput | HostProfileWhereInput[];
      businessName?: StringNullableFilter<'HostProfile'> | string | null;
      description?: StringNullableFilter<'HostProfile'> | string | null;
      rating?: FloatNullableFilter<'HostProfile'> | number | null;
      totalBookings?: IntFilter<'HostProfile'> | number;
      isVerified?: BoolFilter<'HostProfile'> | boolean;
      subscriptionTier?: EnumHostTierFilter<'HostProfile'> | $Enums.HostTier;
      responseRate?: FloatNullableFilter<'HostProfile'> | number | null;
      responseTime?: IntNullableFilter<'HostProfile'> | number | null;
      createdAt?: DateTimeFilter<'HostProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'HostProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'userId'
  >;

  export type HostProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrderInput | SortOrder;
    description?: SortOrderInput | SortOrder;
    rating?: SortOrderInput | SortOrder;
    totalBookings?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    responseRate?: SortOrderInput | SortOrder;
    responseTime?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: HostProfileCountOrderByAggregateInput;
    _avg?: HostProfileAvgOrderByAggregateInput;
    _max?: HostProfileMaxOrderByAggregateInput;
    _min?: HostProfileMinOrderByAggregateInput;
    _sum?: HostProfileSumOrderByAggregateInput;
  };

  export type HostProfileScalarWhereWithAggregatesInput = {
    AND?:
      | HostProfileScalarWhereWithAggregatesInput
      | HostProfileScalarWhereWithAggregatesInput[];
    OR?: HostProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | HostProfileScalarWhereWithAggregatesInput
      | HostProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'HostProfile'> | string;
    userId?: StringWithAggregatesFilter<'HostProfile'> | string;
    businessName?:
      | StringNullableWithAggregatesFilter<'HostProfile'>
      | string
      | null;
    description?:
      | StringNullableWithAggregatesFilter<'HostProfile'>
      | string
      | null;
    rating?: FloatNullableWithAggregatesFilter<'HostProfile'> | number | null;
    totalBookings?: IntWithAggregatesFilter<'HostProfile'> | number;
    isVerified?: BoolWithAggregatesFilter<'HostProfile'> | boolean;
    subscriptionTier?:
      | EnumHostTierWithAggregatesFilter<'HostProfile'>
      | $Enums.HostTier;
    responseRate?:
      | FloatNullableWithAggregatesFilter<'HostProfile'>
      | number
      | null;
    responseTime?:
      | IntNullableWithAggregatesFilter<'HostProfile'>
      | number
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'HostProfile'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'HostProfile'> | Date | string;
  };

  export type AdvertiserProfileWhereInput = {
    AND?: AdvertiserProfileWhereInput | AdvertiserProfileWhereInput[];
    OR?: AdvertiserProfileWhereInput[];
    NOT?: AdvertiserProfileWhereInput | AdvertiserProfileWhereInput[];
    id?: StringFilter<'AdvertiserProfile'> | string;
    userId?: StringFilter<'AdvertiserProfile'> | string;
    companyName?: StringFilter<'AdvertiserProfile'> | string;
    industry?: StringFilter<'AdvertiserProfile'> | string;
    website?: StringNullableFilter<'AdvertiserProfile'> | string | null;
    totalSpend?: FloatFilter<'AdvertiserProfile'> | number;
    isVerified?: BoolFilter<'AdvertiserProfile'> | boolean;
    createdAt?: DateTimeFilter<'AdvertiserProfile'> | Date | string;
    updatedAt?: DateTimeFilter<'AdvertiserProfile'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type AdvertiserProfileOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    companyName?: SortOrder;
    industry?: SortOrder;
    website?: SortOrderInput | SortOrder;
    totalSpend?: SortOrder;
    isVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type AdvertiserProfileWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: AdvertiserProfileWhereInput | AdvertiserProfileWhereInput[];
      OR?: AdvertiserProfileWhereInput[];
      NOT?: AdvertiserProfileWhereInput | AdvertiserProfileWhereInput[];
      companyName?: StringFilter<'AdvertiserProfile'> | string;
      industry?: StringFilter<'AdvertiserProfile'> | string;
      website?: StringNullableFilter<'AdvertiserProfile'> | string | null;
      totalSpend?: FloatFilter<'AdvertiserProfile'> | number;
      isVerified?: BoolFilter<'AdvertiserProfile'> | boolean;
      createdAt?: DateTimeFilter<'AdvertiserProfile'> | Date | string;
      updatedAt?: DateTimeFilter<'AdvertiserProfile'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'userId'
  >;

  export type AdvertiserProfileOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    companyName?: SortOrder;
    industry?: SortOrder;
    website?: SortOrderInput | SortOrder;
    totalSpend?: SortOrder;
    isVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AdvertiserProfileCountOrderByAggregateInput;
    _avg?: AdvertiserProfileAvgOrderByAggregateInput;
    _max?: AdvertiserProfileMaxOrderByAggregateInput;
    _min?: AdvertiserProfileMinOrderByAggregateInput;
    _sum?: AdvertiserProfileSumOrderByAggregateInput;
  };

  export type AdvertiserProfileScalarWhereWithAggregatesInput = {
    AND?:
      | AdvertiserProfileScalarWhereWithAggregatesInput
      | AdvertiserProfileScalarWhereWithAggregatesInput[];
    OR?: AdvertiserProfileScalarWhereWithAggregatesInput[];
    NOT?:
      | AdvertiserProfileScalarWhereWithAggregatesInput
      | AdvertiserProfileScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AdvertiserProfile'> | string;
    userId?: StringWithAggregatesFilter<'AdvertiserProfile'> | string;
    companyName?: StringWithAggregatesFilter<'AdvertiserProfile'> | string;
    industry?: StringWithAggregatesFilter<'AdvertiserProfile'> | string;
    website?:
      | StringNullableWithAggregatesFilter<'AdvertiserProfile'>
      | string
      | null;
    totalSpend?: FloatWithAggregatesFilter<'AdvertiserProfile'> | number;
    isVerified?: BoolWithAggregatesFilter<'AdvertiserProfile'> | boolean;
    createdAt?:
      | DateTimeWithAggregatesFilter<'AdvertiserProfile'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'AdvertiserProfile'>
      | Date
      | string;
  };

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[];
    OR?: AddressWhereInput[];
    NOT?: AddressWhereInput | AddressWhereInput[];
    id?: StringFilter<'Address'> | string;
    customerProfileId?: StringFilter<'Address'> | string;
    label?: StringFilter<'Address'> | string;
    address?: StringFilter<'Address'> | string;
    city?: StringFilter<'Address'> | string;
    country?: StringFilter<'Address'> | string;
    isDefault?: BoolFilter<'Address'> | boolean;
    createdAt?: DateTimeFilter<'Address'> | Date | string;
    updatedAt?: DateTimeFilter<'Address'> | Date | string;
    customerProfile?: XOR<
      CustomerProfileRelationFilter,
      CustomerProfileWhereInput
    >;
  };

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder;
    customerProfileId?: SortOrder;
    label?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    country?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    customerProfile?: CustomerProfileOrderByWithRelationInput;
  };

  export type AddressWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AddressWhereInput | AddressWhereInput[];
      OR?: AddressWhereInput[];
      NOT?: AddressWhereInput | AddressWhereInput[];
      customerProfileId?: StringFilter<'Address'> | string;
      label?: StringFilter<'Address'> | string;
      address?: StringFilter<'Address'> | string;
      city?: StringFilter<'Address'> | string;
      country?: StringFilter<'Address'> | string;
      isDefault?: BoolFilter<'Address'> | boolean;
      createdAt?: DateTimeFilter<'Address'> | Date | string;
      updatedAt?: DateTimeFilter<'Address'> | Date | string;
      customerProfile?: XOR<
        CustomerProfileRelationFilter,
        CustomerProfileWhereInput
      >;
    },
    'id'
  >;

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder;
    customerProfileId?: SortOrder;
    label?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    country?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AddressCountOrderByAggregateInput;
    _max?: AddressMaxOrderByAggregateInput;
    _min?: AddressMinOrderByAggregateInput;
  };

  export type AddressScalarWhereWithAggregatesInput = {
    AND?:
      | AddressScalarWhereWithAggregatesInput
      | AddressScalarWhereWithAggregatesInput[];
    OR?: AddressScalarWhereWithAggregatesInput[];
    NOT?:
      | AddressScalarWhereWithAggregatesInput
      | AddressScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Address'> | string;
    customerProfileId?: StringWithAggregatesFilter<'Address'> | string;
    label?: StringWithAggregatesFilter<'Address'> | string;
    address?: StringWithAggregatesFilter<'Address'> | string;
    city?: StringWithAggregatesFilter<'Address'> | string;
    country?: StringWithAggregatesFilter<'Address'> | string;
    isDefault?: BoolWithAggregatesFilter<'Address'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Address'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Address'> | Date | string;
  };

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
    OR?: RefreshTokenWhereInput[];
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
    id?: StringFilter<'RefreshToken'> | string;
    token?: StringFilter<'RefreshToken'> | string;
    userId?: StringFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
      OR?: RefreshTokenWhereInput[];
      NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
      userId?: StringFilter<'RefreshToken'> | string;
      expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
      createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'token'
  >;

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: RefreshTokenCountOrderByAggregateInput;
    _max?: RefreshTokenMaxOrderByAggregateInput;
    _min?: RefreshTokenMinOrderByAggregateInput;
  };

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?:
      | RefreshTokenScalarWhereWithAggregatesInput
      | RefreshTokenScalarWhereWithAggregatesInput[];
    OR?: RefreshTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | RefreshTokenScalarWhereWithAggregatesInput
      | RefreshTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RefreshToken'> | string;
    token?: StringWithAggregatesFilter<'RefreshToken'> | string;
    userId?: StringWithAggregatesFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeWithAggregatesFilter<'RefreshToken'> | Date | string;
    createdAt?: DateTimeWithAggregatesFilter<'RefreshToken'> | Date | string;
  };

  export type EmailVerificationTokenWhereInput = {
    AND?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    OR?: EmailVerificationTokenWhereInput[];
    NOT?: EmailVerificationTokenWhereInput | EmailVerificationTokenWhereInput[];
    id?: StringFilter<'EmailVerificationToken'> | string;
    token?: StringFilter<'EmailVerificationToken'> | string;
    userId?: StringFilter<'EmailVerificationToken'> | string;
    expiresAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
    createdAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type EmailVerificationTokenOrderByWithRelationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type EmailVerificationTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?:
        | EmailVerificationTokenWhereInput
        | EmailVerificationTokenWhereInput[];
      OR?: EmailVerificationTokenWhereInput[];
      NOT?:
        | EmailVerificationTokenWhereInput
        | EmailVerificationTokenWhereInput[];
      userId?: StringFilter<'EmailVerificationToken'> | string;
      expiresAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
      createdAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'token'
  >;

  export type EmailVerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: EmailVerificationTokenCountOrderByAggregateInput;
    _max?: EmailVerificationTokenMaxOrderByAggregateInput;
    _min?: EmailVerificationTokenMinOrderByAggregateInput;
  };

  export type EmailVerificationTokenScalarWhereWithAggregatesInput = {
    AND?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    OR?: EmailVerificationTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | EmailVerificationTokenScalarWhereWithAggregatesInput
      | EmailVerificationTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    token?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    userId?: StringWithAggregatesFilter<'EmailVerificationToken'> | string;
    expiresAt?:
      | DateTimeWithAggregatesFilter<'EmailVerificationToken'>
      | Date
      | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'EmailVerificationToken'>
      | Date
      | string;
  };

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[];
    OR?: PasswordResetTokenWhereInput[];
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[];
    id?: StringFilter<'PasswordResetToken'> | string;
    token?: StringFilter<'PasswordResetToken'> | string;
    userId?: StringFilter<'PasswordResetToken'> | string;
    expiresAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
    createdAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[];
      OR?: PasswordResetTokenWhereInput[];
      NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[];
      userId?: StringFilter<'PasswordResetToken'> | string;
      expiresAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
      createdAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'token'
  >;

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: PasswordResetTokenCountOrderByAggregateInput;
    _max?: PasswordResetTokenMaxOrderByAggregateInput;
    _min?: PasswordResetTokenMinOrderByAggregateInput;
  };

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?:
      | PasswordResetTokenScalarWhereWithAggregatesInput
      | PasswordResetTokenScalarWhereWithAggregatesInput[];
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | PasswordResetTokenScalarWhereWithAggregatesInput
      | PasswordResetTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PasswordResetToken'> | string;
    token?: StringWithAggregatesFilter<'PasswordResetToken'> | string;
    userId?: StringWithAggregatesFilter<'PasswordResetToken'> | string;
    expiresAt?:
      | DateTimeWithAggregatesFilter<'PasswordResetToken'>
      | Date
      | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'PasswordResetToken'>
      | Date
      | string;
  };

  export type PhoneVerificationCodeWhereInput = {
    AND?: PhoneVerificationCodeWhereInput | PhoneVerificationCodeWhereInput[];
    OR?: PhoneVerificationCodeWhereInput[];
    NOT?: PhoneVerificationCodeWhereInput | PhoneVerificationCodeWhereInput[];
    id?: StringFilter<'PhoneVerificationCode'> | string;
    code?: StringFilter<'PhoneVerificationCode'> | string;
    userId?: StringFilter<'PhoneVerificationCode'> | string;
    expiresAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
    createdAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
    user?: XOR<UserRelationFilter, UserWhereInput>;
  };

  export type PhoneVerificationCodeOrderByWithRelationInput = {
    id?: SortOrder;
    code?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PhoneVerificationCodeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_code?: PhoneVerificationCodeUserIdCodeCompoundUniqueInput;
      AND?: PhoneVerificationCodeWhereInput | PhoneVerificationCodeWhereInput[];
      OR?: PhoneVerificationCodeWhereInput[];
      NOT?: PhoneVerificationCodeWhereInput | PhoneVerificationCodeWhereInput[];
      code?: StringFilter<'PhoneVerificationCode'> | string;
      userId?: StringFilter<'PhoneVerificationCode'> | string;
      expiresAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
      createdAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
      user?: XOR<UserRelationFilter, UserWhereInput>;
    },
    'id' | 'userId_code'
  >;

  export type PhoneVerificationCodeOrderByWithAggregationInput = {
    id?: SortOrder;
    code?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    _count?: PhoneVerificationCodeCountOrderByAggregateInput;
    _max?: PhoneVerificationCodeMaxOrderByAggregateInput;
    _min?: PhoneVerificationCodeMinOrderByAggregateInput;
  };

  export type PhoneVerificationCodeScalarWhereWithAggregatesInput = {
    AND?:
      | PhoneVerificationCodeScalarWhereWithAggregatesInput
      | PhoneVerificationCodeScalarWhereWithAggregatesInput[];
    OR?: PhoneVerificationCodeScalarWhereWithAggregatesInput[];
    NOT?:
      | PhoneVerificationCodeScalarWhereWithAggregatesInput
      | PhoneVerificationCodeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PhoneVerificationCode'> | string;
    code?: StringWithAggregatesFilter<'PhoneVerificationCode'> | string;
    userId?: StringWithAggregatesFilter<'PhoneVerificationCode'> | string;
    expiresAt?:
      | DateTimeWithAggregatesFilter<'PhoneVerificationCode'>
      | Date
      | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'PhoneVerificationCode'>
      | Date
      | string;
  };

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[];
    OR?: AuditLogWhereInput[];
    NOT?: AuditLogWhereInput | AuditLogWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    adminUserId?: StringFilter<'AuditLog'> | string;
    targetUserId?: StringNullableFilter<'AuditLog'> | string | null;
    details?: JsonFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
    adminUser?: XOR<UserRelationFilter, UserWhereInput>;
    targetUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
  };

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder;
    action?: SortOrder;
    adminUserId?: SortOrder;
    targetUserId?: SortOrderInput | SortOrder;
    details?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    adminUser?: UserOrderByWithRelationInput;
    targetUser?: UserOrderByWithRelationInput;
  };

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AuditLogWhereInput | AuditLogWhereInput[];
      OR?: AuditLogWhereInput[];
      NOT?: AuditLogWhereInput | AuditLogWhereInput[];
      action?: StringFilter<'AuditLog'> | string;
      adminUserId?: StringFilter<'AuditLog'> | string;
      targetUserId?: StringNullableFilter<'AuditLog'> | string | null;
      details?: JsonFilter<'AuditLog'>;
      ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
      userAgent?: StringNullableFilter<'AuditLog'> | string | null;
      createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
      adminUser?: XOR<UserRelationFilter, UserWhereInput>;
      targetUser?: XOR<UserNullableRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder;
    action?: SortOrder;
    adminUserId?: SortOrder;
    targetUserId?: SortOrderInput | SortOrder;
    details?: SortOrder;
    ipAddress?: SortOrderInput | SortOrder;
    userAgent?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: AuditLogCountOrderByAggregateInput;
    _max?: AuditLogMaxOrderByAggregateInput;
    _min?: AuditLogMinOrderByAggregateInput;
  };

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    OR?: AuditLogScalarWhereWithAggregatesInput[];
    NOT?:
      | AuditLogScalarWhereWithAggregatesInput
      | AuditLogScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AuditLog'> | string;
    action?: StringWithAggregatesFilter<'AuditLog'> | string;
    adminUserId?: StringWithAggregatesFilter<'AuditLog'> | string;
    targetUserId?:
      | StringNullableWithAggregatesFilter<'AuditLog'>
      | string
      | null;
    details?: JsonWithAggregatesFilter<'AuditLog'>;
    ipAddress?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableWithAggregatesFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'AuditLog'> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
  };

  export type RoleCreateInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: PermissionCreateNestedManyWithoutRolesInput;
    users?: UserRoleCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput;
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: PermissionUpdateManyWithoutRolesNestedInput;
    users?: UserRoleUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput;
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleCreateManyInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    roles?: RoleCreateNestedManyWithoutPermissionsInput;
  };

  export type PermissionUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
    roles?: RoleUncheckedCreateNestedManyWithoutPermissionsInput;
  };

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    roles?: RoleUpdateManyWithoutPermissionsNestedInput;
  };

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    roles?: RoleUncheckedUpdateManyWithoutPermissionsNestedInput;
  };

  export type PermissionCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
  };

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleCreateInput = {
    id?: string;
    assignedAt?: Date | string;
    user: UserCreateNestedOneWithoutRolesInput;
    role: RoleCreateNestedOneWithoutUsersInput;
  };

  export type UserRoleUncheckedCreateInput = {
    id?: string;
    userId: string;
    roleId: string;
    assignedAt?: Date | string;
  };

  export type UserRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutRolesNestedInput;
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type UserRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleCreateManyInput = {
    id?: string;
    userId: string;
    roleId: string;
    assignedAt?: Date | string;
  };

  export type UserRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CustomerProfileCreateInput = {
    id?: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCustomerProfileInput;
    addresses?: AddressCreateNestedManyWithoutCustomerProfileInput;
  };

  export type CustomerProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerProfileInput;
  };

  export type CustomerProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput;
    addresses?: AddressUpdateManyWithoutCustomerProfileNestedInput;
  };

  export type CustomerProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    addresses?: AddressUncheckedUpdateManyWithoutCustomerProfileNestedInput;
  };

  export type CustomerProfileCreateManyInput = {
    id?: string;
    userId: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CustomerProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CustomerProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VendorProfileCreateInput = {
    id?: string;
    businessName: string;
    businessType: string;
    description?: string | null;
    logo?: string | null;
    website?: string | null;
    subscriptionTier?: $Enums.SubscriptionTier;
    commissionRate?: number;
    isVerified?: boolean;
    rating?: number | null;
    totalSales?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutVendorProfileInput;
  };

  export type VendorProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    businessName: string;
    businessType: string;
    description?: string | null;
    logo?: string | null;
    website?: string | null;
    subscriptionTier?: $Enums.SubscriptionTier;
    commissionRate?: number;
    isVerified?: boolean;
    rating?: number | null;
    totalSales?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VendorProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutVendorProfileNestedInput;
  };

  export type VendorProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VendorProfileCreateManyInput = {
    id?: string;
    userId: string;
    businessName: string;
    businessType: string;
    description?: string | null;
    logo?: string | null;
    website?: string | null;
    subscriptionTier?: $Enums.SubscriptionTier;
    commissionRate?: number;
    isVerified?: boolean;
    rating?: number | null;
    totalSales?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VendorProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VendorProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DriverProfileCreateInput = {
    id?: string;
    licenseNumber: string;
    vehicleInfo: JsonNullValueInput | InputJsonValue;
    isOnline?: boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: number | null;
    totalRides?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.DriverTier;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutDriverProfileInput;
  };

  export type DriverProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    licenseNumber: string;
    vehicleInfo: JsonNullValueInput | InputJsonValue;
    isOnline?: boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: number | null;
    totalRides?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.DriverTier;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DriverProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput;
  };

  export type DriverProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DriverProfileCreateManyInput = {
    id?: string;
    userId: string;
    licenseNumber: string;
    vehicleInfo: JsonNullValueInput | InputJsonValue;
    isOnline?: boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: number | null;
    totalRides?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.DriverTier;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DriverProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DriverProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HostProfileCreateInput = {
    id?: string;
    businessName?: string | null;
    description?: string | null;
    rating?: number | null;
    totalBookings?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.HostTier;
    responseRate?: number | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutHostProfileInput;
  };

  export type HostProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    businessName?: string | null;
    description?: string | null;
    rating?: number | null;
    totalBookings?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.HostTier;
    responseRate?: number | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HostProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutHostProfileNestedInput;
  };

  export type HostProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HostProfileCreateManyInput = {
    id?: string;
    userId: string;
    businessName?: string | null;
    description?: string | null;
    rating?: number | null;
    totalBookings?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.HostTier;
    responseRate?: number | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HostProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HostProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdvertiserProfileCreateInput = {
    id?: string;
    companyName: string;
    industry: string;
    website?: string | null;
    totalSpend?: number;
    isVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutAdvertiserProfileInput;
  };

  export type AdvertiserProfileUncheckedCreateInput = {
    id?: string;
    userId: string;
    companyName: string;
    industry: string;
    website?: string | null;
    totalSpend?: number;
    isVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AdvertiserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAdvertiserProfileNestedInput;
  };

  export type AdvertiserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdvertiserProfileCreateManyInput = {
    id?: string;
    userId: string;
    companyName: string;
    industry: string;
    website?: string | null;
    totalSpend?: number;
    isVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AdvertiserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdvertiserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateInput = {
    id?: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    customerProfile: CustomerProfileCreateNestedOneWithoutAddressesInput;
  };

  export type AddressUncheckedCreateInput = {
    id?: string;
    customerProfileId: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    customerProfile?: CustomerProfileUpdateOneRequiredWithoutAddressesNestedInput;
  };

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerProfileId?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateManyInput = {
    id?: string;
    customerProfileId: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    customerProfileId?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenCreateInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutRefreshTokensInput;
  };

  export type RefreshTokenUncheckedCreateInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput;
  };

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenCreateManyInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenCreateInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutEmailVerificationTokensInput;
  };

  export type EmailVerificationTokenUncheckedCreateInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput;
  };

  export type EmailVerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenCreateManyInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenCreateInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutPasswordResetTokensInput;
  };

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput;
  };

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenCreateManyInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeCreateInput = {
    id?: string;
    code: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutPhoneVerificationCodesInput;
  };

  export type PhoneVerificationCodeUncheckedCreateInput = {
    id?: string;
    code: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PhoneVerificationCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutPhoneVerificationCodesNestedInput;
  };

  export type PhoneVerificationCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeCreateManyInput = {
    id?: string;
    code: string;
    userId: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PhoneVerificationCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateInput = {
    id?: string;
    action: string;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    adminUser: UserCreateNestedOneWithoutAdminAuditLogsInput;
    targetUser?: UserCreateNestedOneWithoutTargetAuditLogsInput;
  };

  export type AuditLogUncheckedCreateInput = {
    id?: string;
    action: string;
    adminUserId: string;
    targetUserId?: string | null;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminUser?: UserUpdateOneRequiredWithoutAdminAuditLogsNestedInput;
    targetUser?: UserUpdateOneWithoutTargetAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    adminUserId?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogCreateManyInput = {
    id?: string;
    action: string;
    adminUserId: string;
    targetUserId?: string | null;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    adminUserId?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>;
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName;
  };

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput;
    some?: UserRoleWhereInput;
    none?: UserRoleWhereInput;
  };

  export type CustomerProfileNullableRelationFilter = {
    is?: CustomerProfileWhereInput | null;
    isNot?: CustomerProfileWhereInput | null;
  };

  export type VendorProfileNullableRelationFilter = {
    is?: VendorProfileWhereInput | null;
    isNot?: VendorProfileWhereInput | null;
  };

  export type DriverProfileNullableRelationFilter = {
    is?: DriverProfileWhereInput | null;
    isNot?: DriverProfileWhereInput | null;
  };

  export type HostProfileNullableRelationFilter = {
    is?: HostProfileWhereInput | null;
    isNot?: HostProfileWhereInput | null;
  };

  export type AdvertiserProfileNullableRelationFilter = {
    is?: AdvertiserProfileWhereInput | null;
    isNot?: AdvertiserProfileWhereInput | null;
  };

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput;
    some?: RefreshTokenWhereInput;
    none?: RefreshTokenWhereInput;
  };

  export type EmailVerificationTokenListRelationFilter = {
    every?: EmailVerificationTokenWhereInput;
    some?: EmailVerificationTokenWhereInput;
    none?: EmailVerificationTokenWhereInput;
  };

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput;
    some?: PasswordResetTokenWhereInput;
    none?: PasswordResetTokenWhereInput;
  };

  export type PhoneVerificationCodeListRelationFilter = {
    every?: PhoneVerificationCodeWhereInput;
    some?: PhoneVerificationCodeWhereInput;
    none?: PhoneVerificationCodeWhereInput;
  };

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput;
    some?: AuditLogWhereInput;
    none?: AuditLogWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type EmailVerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PhoneVerificationCodeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatar?: SortOrder;
    isEmailVerified?: SortOrder;
    isPhoneVerified?: SortOrder;
    isActive?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    activeRole?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatar?: SortOrder;
    isEmailVerified?: SortOrder;
    isPhoneVerified?: SortOrder;
    isActive?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    activeRole?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    passwordHash?: SortOrder;
    firstName?: SortOrder;
    lastName?: SortOrder;
    avatar?: SortOrder;
    isEmailVerified?: SortOrder;
    isPhoneVerified?: SortOrder;
    isActive?: SortOrder;
    lastLoginAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    activeRole?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>;
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRoleNameWithAggregatesFilter<$PrismaModel>
      | $Enums.RoleName;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleNameFilter<$PrismaModel>;
    _max?: NestedEnumRoleNameFilter<$PrismaModel>;
  };

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput;
    some?: PermissionWhereInput;
    none?: PermissionWhereInput;
  };

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RoleListRelationFilter = {
    every?: RoleWhereInput;
    some?: RoleWhereInput;
    none?: RoleWhereInput;
  };

  export type RoleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type RoleRelationFilter = {
    is?: RoleWhereInput;
    isNot?: RoleWhereInput;
  };

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string;
    roleId: string;
  };

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    assignedAt?: SortOrder;
  };

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    assignedAt?: SortOrder;
  };

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    roleId?: SortOrder;
    assignedAt?: SortOrder;
  };
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type AddressListRelationFilter = {
    every?: AddressWhereInput;
    some?: AddressWhereInput;
    none?: AddressWhereInput;
  };

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CustomerProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    preferences?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CustomerProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CustomerProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<
          Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>,
          'path'
        >
      >;

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedJsonNullableFilter<$PrismaModel>;
    _max?: NestedJsonNullableFilter<$PrismaModel>;
  };

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubscriptionTier
      | EnumSubscriptionTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionTierFilter<$PrismaModel>
      | $Enums.SubscriptionTier;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type VendorProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    businessType?: SortOrder;
    description?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    subscriptionTier?: SortOrder;
    commissionRate?: SortOrder;
    isVerified?: SortOrder;
    rating?: SortOrder;
    totalSales?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VendorProfileAvgOrderByAggregateInput = {
    commissionRate?: SortOrder;
    rating?: SortOrder;
    totalSales?: SortOrder;
  };

  export type VendorProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    businessType?: SortOrder;
    description?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    subscriptionTier?: SortOrder;
    commissionRate?: SortOrder;
    isVerified?: SortOrder;
    rating?: SortOrder;
    totalSales?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VendorProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    businessType?: SortOrder;
    description?: SortOrder;
    logo?: SortOrder;
    website?: SortOrder;
    subscriptionTier?: SortOrder;
    commissionRate?: SortOrder;
    isVerified?: SortOrder;
    rating?: SortOrder;
    totalSales?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type VendorProfileSumOrderByAggregateInput = {
    commissionRate?: SortOrder;
    rating?: SortOrder;
    totalSales?: SortOrder;
  };

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubscriptionTier
      | EnumSubscriptionTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel>
      | $Enums.SubscriptionTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type EnumDriverTierFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverTier | EnumDriverTierFieldRefInput<$PrismaModel>;
    in?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    not?: NestedEnumDriverTierFilter<$PrismaModel> | $Enums.DriverTier;
  };

  export type DriverProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    licenseNumber?: SortOrder;
    vehicleInfo?: SortOrder;
    isOnline?: SortOrder;
    currentLocation?: SortOrder;
    rating?: SortOrder;
    totalRides?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DriverProfileAvgOrderByAggregateInput = {
    rating?: SortOrder;
    totalRides?: SortOrder;
  };

  export type DriverProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    licenseNumber?: SortOrder;
    isOnline?: SortOrder;
    rating?: SortOrder;
    totalRides?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DriverProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    licenseNumber?: SortOrder;
    isOnline?: SortOrder;
    rating?: SortOrder;
    totalRides?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DriverProfileSumOrderByAggregateInput = {
    rating?: SortOrder;
    totalRides?: SortOrder;
  };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumDriverTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverTier | EnumDriverTierFieldRefInput<$PrismaModel>;
    in?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumDriverTierWithAggregatesFilter<$PrismaModel>
      | $Enums.DriverTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDriverTierFilter<$PrismaModel>;
    _max?: NestedEnumDriverTierFilter<$PrismaModel>;
  };

  export type EnumHostTierFilter<$PrismaModel = never> = {
    equals?: $Enums.HostTier | EnumHostTierFieldRefInput<$PrismaModel>;
    in?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    not?: NestedEnumHostTierFilter<$PrismaModel> | $Enums.HostTier;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type HostProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    description?: SortOrder;
    rating?: SortOrder;
    totalBookings?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    responseRate?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HostProfileAvgOrderByAggregateInput = {
    rating?: SortOrder;
    totalBookings?: SortOrder;
    responseRate?: SortOrder;
    responseTime?: SortOrder;
  };

  export type HostProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    description?: SortOrder;
    rating?: SortOrder;
    totalBookings?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    responseRate?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HostProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    businessName?: SortOrder;
    description?: SortOrder;
    rating?: SortOrder;
    totalBookings?: SortOrder;
    isVerified?: SortOrder;
    subscriptionTier?: SortOrder;
    responseRate?: SortOrder;
    responseTime?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type HostProfileSumOrderByAggregateInput = {
    rating?: SortOrder;
    totalBookings?: SortOrder;
    responseRate?: SortOrder;
    responseTime?: SortOrder;
  };

  export type EnumHostTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HostTier | EnumHostTierFieldRefInput<$PrismaModel>;
    in?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHostTierWithAggregatesFilter<$PrismaModel>
      | $Enums.HostTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHostTierFilter<$PrismaModel>;
    _max?: NestedEnumHostTierFilter<$PrismaModel>;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type AdvertiserProfileCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    companyName?: SortOrder;
    industry?: SortOrder;
    website?: SortOrder;
    totalSpend?: SortOrder;
    isVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdvertiserProfileAvgOrderByAggregateInput = {
    totalSpend?: SortOrder;
  };

  export type AdvertiserProfileMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    companyName?: SortOrder;
    industry?: SortOrder;
    website?: SortOrder;
    totalSpend?: SortOrder;
    isVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdvertiserProfileMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    companyName?: SortOrder;
    industry?: SortOrder;
    website?: SortOrder;
    totalSpend?: SortOrder;
    isVerified?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AdvertiserProfileSumOrderByAggregateInput = {
    totalSpend?: SortOrder;
  };

  export type CustomerProfileRelationFilter = {
    is?: CustomerProfileWhereInput;
    isNot?: CustomerProfileWhereInput;
  };

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder;
    customerProfileId?: SortOrder;
    label?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    country?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder;
    customerProfileId?: SortOrder;
    label?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    country?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder;
    customerProfileId?: SortOrder;
    label?: SortOrder;
    address?: SortOrder;
    city?: SortOrder;
    country?: SortOrder;
    isDefault?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EmailVerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PhoneVerificationCodeUserIdCodeCompoundUniqueInput = {
    userId: string;
    code: string;
  };

  export type PhoneVerificationCodeCountOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PhoneVerificationCodeMaxOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PhoneVerificationCodeMinOrderByAggregateInput = {
    id?: SortOrder;
    code?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    adminUserId?: SortOrder;
    targetUserId?: SortOrder;
    details?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    adminUserId?: SortOrder;
    targetUserId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder;
    action?: SortOrder;
    adminUserId?: SortOrder;
    targetUserId?: SortOrder;
    ipAddress?: SortOrder;
    userAgent?: SortOrder;
    createdAt?: SortOrder;
  };

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutUserInput,
          UserRoleUncheckedCreateWithoutUserInput
        >
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutUserInput
      | UserRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type CustomerProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutUserInput;
    connect?: CustomerProfileWhereUniqueInput;
  };

  export type VendorProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: VendorProfileCreateOrConnectWithoutUserInput;
    connect?: VendorProfileWhereUniqueInput;
  };

  export type DriverProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: DriverProfileCreateOrConnectWithoutUserInput;
    connect?: DriverProfileWhereUniqueInput;
  };

  export type HostProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: HostProfileCreateOrConnectWithoutUserInput;
    connect?: HostProfileWhereUniqueInput;
  };

  export type AdvertiserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AdvertiserProfileCreateOrConnectWithoutUserInput;
    connect?: AdvertiserProfileWhereUniqueInput;
  };

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
  };

  export type EmailVerificationTokenCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          EmailVerificationTokenCreateWithoutUserInput,
          EmailVerificationTokenUncheckedCreateWithoutUserInput
        >
      | EmailVerificationTokenCreateWithoutUserInput[]
      | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EmailVerificationTokenCreateOrConnectWithoutUserInput
      | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
    connect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
  };

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PasswordResetTokenCreateWithoutUserInput,
          PasswordResetTokenUncheckedCreateWithoutUserInput
        >
      | PasswordResetTokenCreateWithoutUserInput[]
      | PasswordResetTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PasswordResetTokenCreateOrConnectWithoutUserInput
      | PasswordResetTokenCreateOrConnectWithoutUserInput[];
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope;
    connect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
  };

  export type PhoneVerificationCodeCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PhoneVerificationCodeCreateWithoutUserInput,
          PhoneVerificationCodeUncheckedCreateWithoutUserInput
        >
      | PhoneVerificationCodeCreateWithoutUserInput[]
      | PhoneVerificationCodeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput[];
    createMany?: PhoneVerificationCodeCreateManyUserInputEnvelope;
    connect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutAdminUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutAdminUserInput,
          AuditLogUncheckedCreateWithoutAdminUserInput
        >
      | AuditLogCreateWithoutAdminUserInput[]
      | AuditLogUncheckedCreateWithoutAdminUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutAdminUserInput
      | AuditLogCreateOrConnectWithoutAdminUserInput[];
    createMany?: AuditLogCreateManyAdminUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type AuditLogCreateNestedManyWithoutTargetUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutTargetUserInput,
          AuditLogUncheckedCreateWithoutTargetUserInput
        >
      | AuditLogCreateWithoutTargetUserInput[]
      | AuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutTargetUserInput
      | AuditLogCreateOrConnectWithoutTargetUserInput[];
    createMany?: AuditLogCreateManyTargetUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutUserInput,
          UserRoleUncheckedCreateWithoutUserInput
        >
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutUserInput
      | UserRoleCreateOrConnectWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type CustomerProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutUserInput;
    connect?: CustomerProfileWhereUniqueInput;
  };

  export type VendorProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: VendorProfileCreateOrConnectWithoutUserInput;
    connect?: VendorProfileWhereUniqueInput;
  };

  export type DriverProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: DriverProfileCreateOrConnectWithoutUserInput;
    connect?: DriverProfileWhereUniqueInput;
  };

  export type HostProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: HostProfileCreateOrConnectWithoutUserInput;
    connect?: HostProfileWhereUniqueInput;
  };

  export type AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AdvertiserProfileCreateOrConnectWithoutUserInput;
    connect?: AdvertiserProfileWhereUniqueInput;
  };

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
  };

  export type EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput =
    {
      create?:
        | XOR<
            EmailVerificationTokenCreateWithoutUserInput,
            EmailVerificationTokenUncheckedCreateWithoutUserInput
          >
        | EmailVerificationTokenCreateWithoutUserInput[]
        | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EmailVerificationTokenCreateOrConnectWithoutUserInput
        | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
      createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
      connect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
    };

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PasswordResetTokenCreateWithoutUserInput,
          PasswordResetTokenUncheckedCreateWithoutUserInput
        >
      | PasswordResetTokenCreateWithoutUserInput[]
      | PasswordResetTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PasswordResetTokenCreateOrConnectWithoutUserInput
      | PasswordResetTokenCreateOrConnectWithoutUserInput[];
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope;
    connect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
  };

  export type PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PhoneVerificationCodeCreateWithoutUserInput,
          PhoneVerificationCodeUncheckedCreateWithoutUserInput
        >
      | PhoneVerificationCodeCreateWithoutUserInput[]
      | PhoneVerificationCodeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput[];
    createMany?: PhoneVerificationCodeCreateManyUserInputEnvelope;
    connect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutAdminUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutAdminUserInput,
          AuditLogUncheckedCreateWithoutAdminUserInput
        >
      | AuditLogCreateWithoutAdminUserInput[]
      | AuditLogUncheckedCreateWithoutAdminUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutAdminUserInput
      | AuditLogCreateOrConnectWithoutAdminUserInput[];
    createMany?: AuditLogCreateManyAdminUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type AuditLogUncheckedCreateNestedManyWithoutTargetUserInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutTargetUserInput,
          AuditLogUncheckedCreateWithoutTargetUserInput
        >
      | AuditLogCreateWithoutTargetUserInput[]
      | AuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutTargetUserInput
      | AuditLogCreateOrConnectWithoutTargetUserInput[];
    createMany?: AuditLogCreateManyTargetUserInputEnvelope;
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName;
  };

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutUserInput,
          UserRoleUncheckedCreateWithoutUserInput
        >
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutUserInput
      | UserRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserRoleUpsertWithWhereUniqueWithoutUserInput
      | UserRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?:
      | UserRoleUpdateWithWhereUniqueWithoutUserInput
      | UserRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserRoleUpdateManyWithWhereWithoutUserInput
      | UserRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type CustomerProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutUserInput;
    upsert?: CustomerProfileUpsertWithoutUserInput;
    disconnect?: CustomerProfileWhereInput | boolean;
    delete?: CustomerProfileWhereInput | boolean;
    connect?: CustomerProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerProfileUpdateToOneWithWhereWithoutUserInput,
        CustomerProfileUpdateWithoutUserInput
      >,
      CustomerProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type VendorProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: VendorProfileCreateOrConnectWithoutUserInput;
    upsert?: VendorProfileUpsertWithoutUserInput;
    disconnect?: VendorProfileWhereInput | boolean;
    delete?: VendorProfileWhereInput | boolean;
    connect?: VendorProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        VendorProfileUpdateToOneWithWhereWithoutUserInput,
        VendorProfileUpdateWithoutUserInput
      >,
      VendorProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type DriverProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: DriverProfileCreateOrConnectWithoutUserInput;
    upsert?: DriverProfileUpsertWithoutUserInput;
    disconnect?: DriverProfileWhereInput | boolean;
    delete?: DriverProfileWhereInput | boolean;
    connect?: DriverProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        DriverProfileUpdateToOneWithWhereWithoutUserInput,
        DriverProfileUpdateWithoutUserInput
      >,
      DriverProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type HostProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: HostProfileCreateOrConnectWithoutUserInput;
    upsert?: HostProfileUpsertWithoutUserInput;
    disconnect?: HostProfileWhereInput | boolean;
    delete?: HostProfileWhereInput | boolean;
    connect?: HostProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        HostProfileUpdateToOneWithWhereWithoutUserInput,
        HostProfileUpdateWithoutUserInput
      >,
      HostProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type AdvertiserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AdvertiserProfileCreateOrConnectWithoutUserInput;
    upsert?: AdvertiserProfileUpsertWithoutUserInput;
    disconnect?: AdvertiserProfileWhereInput | boolean;
    delete?: AdvertiserProfileWhereInput | boolean;
    connect?: AdvertiserProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        AdvertiserProfileUpdateToOneWithWhereWithoutUserInput,
        AdvertiserProfileUpdateWithoutUserInput
      >,
      AdvertiserProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    update?:
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | RefreshTokenUpdateManyWithWhereWithoutUserInput
      | RefreshTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
  };

  export type EmailVerificationTokenUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          EmailVerificationTokenCreateWithoutUserInput,
          EmailVerificationTokenUncheckedCreateWithoutUserInput
        >
      | EmailVerificationTokenCreateWithoutUserInput[]
      | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | EmailVerificationTokenCreateOrConnectWithoutUserInput
      | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput
      | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
    set?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    disconnect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    delete?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    connect?:
      | EmailVerificationTokenWhereUniqueInput
      | EmailVerificationTokenWhereUniqueInput[];
    update?:
      | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput
      | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput
      | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
  };

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PasswordResetTokenCreateWithoutUserInput,
          PasswordResetTokenUncheckedCreateWithoutUserInput
        >
      | PasswordResetTokenCreateWithoutUserInput[]
      | PasswordResetTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PasswordResetTokenCreateOrConnectWithoutUserInput
      | PasswordResetTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput
      | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope;
    set?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    disconnect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    delete?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    connect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    update?:
      | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput
      | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PasswordResetTokenUpdateManyWithWhereWithoutUserInput
      | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PasswordResetTokenScalarWhereInput
      | PasswordResetTokenScalarWhereInput[];
  };

  export type PhoneVerificationCodeUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PhoneVerificationCodeCreateWithoutUserInput,
          PhoneVerificationCodeUncheckedCreateWithoutUserInput
        >
      | PhoneVerificationCodeCreateWithoutUserInput[]
      | PhoneVerificationCodeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput[];
    upsert?:
      | PhoneVerificationCodeUpsertWithWhereUniqueWithoutUserInput
      | PhoneVerificationCodeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PhoneVerificationCodeCreateManyUserInputEnvelope;
    set?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    disconnect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    delete?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    connect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    update?:
      | PhoneVerificationCodeUpdateWithWhereUniqueWithoutUserInput
      | PhoneVerificationCodeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PhoneVerificationCodeUpdateManyWithWhereWithoutUserInput
      | PhoneVerificationCodeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PhoneVerificationCodeScalarWhereInput
      | PhoneVerificationCodeScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutAdminUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutAdminUserInput,
          AuditLogUncheckedCreateWithoutAdminUserInput
        >
      | AuditLogCreateWithoutAdminUserInput[]
      | AuditLogUncheckedCreateWithoutAdminUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutAdminUserInput
      | AuditLogCreateOrConnectWithoutAdminUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput
      | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[];
    createMany?: AuditLogCreateManyAdminUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput
      | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutAdminUserInput
      | AuditLogUpdateManyWithWhereWithoutAdminUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type AuditLogUpdateManyWithoutTargetUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutTargetUserInput,
          AuditLogUncheckedCreateWithoutTargetUserInput
        >
      | AuditLogCreateWithoutTargetUserInput[]
      | AuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutTargetUserInput
      | AuditLogCreateOrConnectWithoutTargetUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutTargetUserInput
      | AuditLogUpsertWithWhereUniqueWithoutTargetUserInput[];
    createMany?: AuditLogCreateManyTargetUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutTargetUserInput
      | AuditLogUpdateWithWhereUniqueWithoutTargetUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutTargetUserInput
      | AuditLogUpdateManyWithWhereWithoutTargetUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutUserInput,
          UserRoleUncheckedCreateWithoutUserInput
        >
      | UserRoleCreateWithoutUserInput[]
      | UserRoleUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutUserInput
      | UserRoleCreateOrConnectWithoutUserInput[];
    upsert?:
      | UserRoleUpsertWithWhereUniqueWithoutUserInput
      | UserRoleUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: UserRoleCreateManyUserInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?:
      | UserRoleUpdateWithWhereUniqueWithoutUserInput
      | UserRoleUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | UserRoleUpdateManyWithWhereWithoutUserInput
      | UserRoleUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type CustomerProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutUserInput;
    upsert?: CustomerProfileUpsertWithoutUserInput;
    disconnect?: CustomerProfileWhereInput | boolean;
    delete?: CustomerProfileWhereInput | boolean;
    connect?: CustomerProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerProfileUpdateToOneWithWhereWithoutUserInput,
        CustomerProfileUpdateWithoutUserInput
      >,
      CustomerProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type VendorProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: VendorProfileCreateOrConnectWithoutUserInput;
    upsert?: VendorProfileUpsertWithoutUserInput;
    disconnect?: VendorProfileWhereInput | boolean;
    delete?: VendorProfileWhereInput | boolean;
    connect?: VendorProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        VendorProfileUpdateToOneWithWhereWithoutUserInput,
        VendorProfileUpdateWithoutUserInput
      >,
      VendorProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type DriverProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: DriverProfileCreateOrConnectWithoutUserInput;
    upsert?: DriverProfileUpsertWithoutUserInput;
    disconnect?: DriverProfileWhereInput | boolean;
    delete?: DriverProfileWhereInput | boolean;
    connect?: DriverProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        DriverProfileUpdateToOneWithWhereWithoutUserInput,
        DriverProfileUpdateWithoutUserInput
      >,
      DriverProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type HostProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: HostProfileCreateOrConnectWithoutUserInput;
    upsert?: HostProfileUpsertWithoutUserInput;
    disconnect?: HostProfileWhereInput | boolean;
    delete?: HostProfileWhereInput | boolean;
    connect?: HostProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        HostProfileUpdateToOneWithWhereWithoutUserInput,
        HostProfileUpdateWithoutUserInput
      >,
      HostProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: AdvertiserProfileCreateOrConnectWithoutUserInput;
    upsert?: AdvertiserProfileUpsertWithoutUserInput;
    disconnect?: AdvertiserProfileWhereInput | boolean;
    delete?: AdvertiserProfileWhereInput | boolean;
    connect?: AdvertiserProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        AdvertiserProfileUpdateToOneWithWhereWithoutUserInput,
        AdvertiserProfileUpdateWithoutUserInput
      >,
      AdvertiserProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    update?:
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | RefreshTokenUpdateManyWithWhereWithoutUserInput
      | RefreshTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
  };

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput =
    {
      create?:
        | XOR<
            EmailVerificationTokenCreateWithoutUserInput,
            EmailVerificationTokenUncheckedCreateWithoutUserInput
          >
        | EmailVerificationTokenCreateWithoutUserInput[]
        | EmailVerificationTokenUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
        | EmailVerificationTokenCreateOrConnectWithoutUserInput
        | EmailVerificationTokenCreateOrConnectWithoutUserInput[];
      upsert?:
        | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput
        | EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput[];
      createMany?: EmailVerificationTokenCreateManyUserInputEnvelope;
      set?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      disconnect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      delete?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      connect?:
        | EmailVerificationTokenWhereUniqueInput
        | EmailVerificationTokenWhereUniqueInput[];
      update?:
        | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput
        | EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput[];
      updateMany?:
        | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput
        | EmailVerificationTokenUpdateManyWithWhereWithoutUserInput[];
      deleteMany?:
        | EmailVerificationTokenScalarWhereInput
        | EmailVerificationTokenScalarWhereInput[];
    };

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PasswordResetTokenCreateWithoutUserInput,
          PasswordResetTokenUncheckedCreateWithoutUserInput
        >
      | PasswordResetTokenCreateWithoutUserInput[]
      | PasswordResetTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PasswordResetTokenCreateOrConnectWithoutUserInput
      | PasswordResetTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput
      | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope;
    set?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    disconnect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    delete?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    connect?:
      | PasswordResetTokenWhereUniqueInput
      | PasswordResetTokenWhereUniqueInput[];
    update?:
      | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput
      | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PasswordResetTokenUpdateManyWithWhereWithoutUserInput
      | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PasswordResetTokenScalarWhereInput
      | PasswordResetTokenScalarWhereInput[];
  };

  export type PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PhoneVerificationCodeCreateWithoutUserInput,
          PhoneVerificationCodeUncheckedCreateWithoutUserInput
        >
      | PhoneVerificationCodeCreateWithoutUserInput[]
      | PhoneVerificationCodeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput
      | PhoneVerificationCodeCreateOrConnectWithoutUserInput[];
    upsert?:
      | PhoneVerificationCodeUpsertWithWhereUniqueWithoutUserInput
      | PhoneVerificationCodeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PhoneVerificationCodeCreateManyUserInputEnvelope;
    set?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    disconnect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    delete?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    connect?:
      | PhoneVerificationCodeWhereUniqueInput
      | PhoneVerificationCodeWhereUniqueInput[];
    update?:
      | PhoneVerificationCodeUpdateWithWhereUniqueWithoutUserInput
      | PhoneVerificationCodeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PhoneVerificationCodeUpdateManyWithWhereWithoutUserInput
      | PhoneVerificationCodeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PhoneVerificationCodeScalarWhereInput
      | PhoneVerificationCodeScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutAdminUserInput,
          AuditLogUncheckedCreateWithoutAdminUserInput
        >
      | AuditLogCreateWithoutAdminUserInput[]
      | AuditLogUncheckedCreateWithoutAdminUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutAdminUserInput
      | AuditLogCreateOrConnectWithoutAdminUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput
      | AuditLogUpsertWithWhereUniqueWithoutAdminUserInput[];
    createMany?: AuditLogCreateManyAdminUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput
      | AuditLogUpdateWithWhereUniqueWithoutAdminUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutAdminUserInput
      | AuditLogUpdateManyWithWhereWithoutAdminUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput = {
    create?:
      | XOR<
          AuditLogCreateWithoutTargetUserInput,
          AuditLogUncheckedCreateWithoutTargetUserInput
        >
      | AuditLogCreateWithoutTargetUserInput[]
      | AuditLogUncheckedCreateWithoutTargetUserInput[];
    connectOrCreate?:
      | AuditLogCreateOrConnectWithoutTargetUserInput
      | AuditLogCreateOrConnectWithoutTargetUserInput[];
    upsert?:
      | AuditLogUpsertWithWhereUniqueWithoutTargetUserInput
      | AuditLogUpsertWithWhereUniqueWithoutTargetUserInput[];
    createMany?: AuditLogCreateManyTargetUserInputEnvelope;
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[];
    update?:
      | AuditLogUpdateWithWhereUniqueWithoutTargetUserInput
      | AuditLogUpdateWithWhereUniqueWithoutTargetUserInput[];
    updateMany?:
      | AuditLogUpdateManyWithWhereWithoutTargetUserInput
      | AuditLogUpdateManyWithWhereWithoutTargetUserInput[];
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
  };

  export type PermissionCreateNestedManyWithoutRolesInput = {
    create?:
      | XOR<
          PermissionCreateWithoutRolesInput,
          PermissionUncheckedCreateWithoutRolesInput
        >
      | PermissionCreateWithoutRolesInput[]
      | PermissionUncheckedCreateWithoutRolesInput[];
    connectOrCreate?:
      | PermissionCreateOrConnectWithoutRolesInput
      | PermissionCreateOrConnectWithoutRolesInput[];
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
  };

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutRoleInput,
          UserRoleUncheckedCreateWithoutRoleInput
        >
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutRoleInput
      | UserRoleCreateOrConnectWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type PermissionUncheckedCreateNestedManyWithoutRolesInput = {
    create?:
      | XOR<
          PermissionCreateWithoutRolesInput,
          PermissionUncheckedCreateWithoutRolesInput
        >
      | PermissionCreateWithoutRolesInput[]
      | PermissionUncheckedCreateWithoutRolesInput[];
    connectOrCreate?:
      | PermissionCreateOrConnectWithoutRolesInput
      | PermissionCreateOrConnectWithoutRolesInput[];
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
  };

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutRoleInput,
          UserRoleUncheckedCreateWithoutRoleInput
        >
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutRoleInput
      | UserRoleCreateOrConnectWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
  };

  export type PermissionUpdateManyWithoutRolesNestedInput = {
    create?:
      | XOR<
          PermissionCreateWithoutRolesInput,
          PermissionUncheckedCreateWithoutRolesInput
        >
      | PermissionCreateWithoutRolesInput[]
      | PermissionUncheckedCreateWithoutRolesInput[];
    connectOrCreate?:
      | PermissionCreateOrConnectWithoutRolesInput
      | PermissionCreateOrConnectWithoutRolesInput[];
    upsert?:
      | PermissionUpsertWithWhereUniqueWithoutRolesInput
      | PermissionUpsertWithWhereUniqueWithoutRolesInput[];
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    update?:
      | PermissionUpdateWithWhereUniqueWithoutRolesInput
      | PermissionUpdateWithWhereUniqueWithoutRolesInput[];
    updateMany?:
      | PermissionUpdateManyWithWhereWithoutRolesInput
      | PermissionUpdateManyWithWhereWithoutRolesInput[];
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[];
  };

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutRoleInput,
          UserRoleUncheckedCreateWithoutRoleInput
        >
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutRoleInput
      | UserRoleCreateOrConnectWithoutRoleInput[];
    upsert?:
      | UserRoleUpsertWithWhereUniqueWithoutRoleInput
      | UserRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?:
      | UserRoleUpdateWithWhereUniqueWithoutRoleInput
      | UserRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | UserRoleUpdateManyWithWhereWithoutRoleInput
      | UserRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type PermissionUncheckedUpdateManyWithoutRolesNestedInput = {
    create?:
      | XOR<
          PermissionCreateWithoutRolesInput,
          PermissionUncheckedCreateWithoutRolesInput
        >
      | PermissionCreateWithoutRolesInput[]
      | PermissionUncheckedCreateWithoutRolesInput[];
    connectOrCreate?:
      | PermissionCreateOrConnectWithoutRolesInput
      | PermissionCreateOrConnectWithoutRolesInput[];
    upsert?:
      | PermissionUpsertWithWhereUniqueWithoutRolesInput
      | PermissionUpsertWithWhereUniqueWithoutRolesInput[];
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[];
    update?:
      | PermissionUpdateWithWhereUniqueWithoutRolesInput
      | PermissionUpdateWithWhereUniqueWithoutRolesInput[];
    updateMany?:
      | PermissionUpdateManyWithWhereWithoutRolesInput
      | PermissionUpdateManyWithWhereWithoutRolesInput[];
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[];
  };

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?:
      | XOR<
          UserRoleCreateWithoutRoleInput,
          UserRoleUncheckedCreateWithoutRoleInput
        >
      | UserRoleCreateWithoutRoleInput[]
      | UserRoleUncheckedCreateWithoutRoleInput[];
    connectOrCreate?:
      | UserRoleCreateOrConnectWithoutRoleInput
      | UserRoleCreateOrConnectWithoutRoleInput[];
    upsert?:
      | UserRoleUpsertWithWhereUniqueWithoutRoleInput
      | UserRoleUpsertWithWhereUniqueWithoutRoleInput[];
    createMany?: UserRoleCreateManyRoleInputEnvelope;
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[];
    update?:
      | UserRoleUpdateWithWhereUniqueWithoutRoleInput
      | UserRoleUpdateWithWhereUniqueWithoutRoleInput[];
    updateMany?:
      | UserRoleUpdateManyWithWhereWithoutRoleInput
      | UserRoleUpdateManyWithWhereWithoutRoleInput[];
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
  };

  export type RoleCreateNestedManyWithoutPermissionsInput = {
    create?:
      | XOR<
          RoleCreateWithoutPermissionsInput,
          RoleUncheckedCreateWithoutPermissionsInput
        >
      | RoleCreateWithoutPermissionsInput[]
      | RoleUncheckedCreateWithoutPermissionsInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutPermissionsInput
      | RoleCreateOrConnectWithoutPermissionsInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type RoleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?:
      | XOR<
          RoleCreateWithoutPermissionsInput,
          RoleUncheckedCreateWithoutPermissionsInput
        >
      | RoleCreateWithoutPermissionsInput[]
      | RoleUncheckedCreateWithoutPermissionsInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutPermissionsInput
      | RoleCreateOrConnectWithoutPermissionsInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
  };

  export type RoleUpdateManyWithoutPermissionsNestedInput = {
    create?:
      | XOR<
          RoleCreateWithoutPermissionsInput,
          RoleUncheckedCreateWithoutPermissionsInput
        >
      | RoleCreateWithoutPermissionsInput[]
      | RoleUncheckedCreateWithoutPermissionsInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutPermissionsInput
      | RoleCreateOrConnectWithoutPermissionsInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutPermissionsInput
      | RoleUpsertWithWhereUniqueWithoutPermissionsInput[];
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutPermissionsInput
      | RoleUpdateWithWhereUniqueWithoutPermissionsInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutPermissionsInput
      | RoleUpdateManyWithWhereWithoutPermissionsInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type RoleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?:
      | XOR<
          RoleCreateWithoutPermissionsInput,
          RoleUncheckedCreateWithoutPermissionsInput
        >
      | RoleCreateWithoutPermissionsInput[]
      | RoleUncheckedCreateWithoutPermissionsInput[];
    connectOrCreate?:
      | RoleCreateOrConnectWithoutPermissionsInput
      | RoleCreateOrConnectWithoutPermissionsInput[];
    upsert?:
      | RoleUpsertWithWhereUniqueWithoutPermissionsInput
      | RoleUpsertWithWhereUniqueWithoutPermissionsInput[];
    set?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    disconnect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    delete?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    connect?: RoleWhereUniqueInput | RoleWhereUniqueInput[];
    update?:
      | RoleUpdateWithWhereUniqueWithoutPermissionsInput
      | RoleUpdateWithWhereUniqueWithoutPermissionsInput[];
    updateMany?:
      | RoleUpdateManyWithWhereWithoutPermissionsInput
      | RoleUpdateManyWithWhereWithoutPermissionsInput[];
    deleteMany?: RoleScalarWhereInput | RoleScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<
      UserCreateWithoutRolesInput,
      UserUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput;
    connect?: UserWhereUniqueInput;
  };

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<
      RoleCreateWithoutUsersInput,
      RoleUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput;
    connect?: RoleWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<
      UserCreateWithoutRolesInput,
      UserUncheckedCreateWithoutRolesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput;
    upsert?: UserUpsertWithoutRolesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRolesInput,
        UserUpdateWithoutRolesInput
      >,
      UserUncheckedUpdateWithoutRolesInput
    >;
  };

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<
      RoleCreateWithoutUsersInput,
      RoleUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput;
    upsert?: RoleUpsertWithoutUsersInput;
    connect?: RoleWhereUniqueInput;
    update?: XOR<
      XOR<
        RoleUpdateToOneWithWhereWithoutUsersInput,
        RoleUpdateWithoutUsersInput
      >,
      RoleUncheckedUpdateWithoutUsersInput
    >;
  };

  export type UserCreateNestedOneWithoutCustomerProfileInput = {
    create?: XOR<
      UserCreateWithoutCustomerProfileInput,
      UserUncheckedCreateWithoutCustomerProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCustomerProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type AddressCreateNestedManyWithoutCustomerProfileInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerProfileInput,
          AddressUncheckedCreateWithoutCustomerProfileInput
        >
      | AddressCreateWithoutCustomerProfileInput[]
      | AddressUncheckedCreateWithoutCustomerProfileInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerProfileInput
      | AddressCreateOrConnectWithoutCustomerProfileInput[];
    createMany?: AddressCreateManyCustomerProfileInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type AddressUncheckedCreateNestedManyWithoutCustomerProfileInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerProfileInput,
          AddressUncheckedCreateWithoutCustomerProfileInput
        >
      | AddressCreateWithoutCustomerProfileInput[]
      | AddressUncheckedCreateWithoutCustomerProfileInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerProfileInput
      | AddressCreateOrConnectWithoutCustomerProfileInput[];
    createMany?: AddressCreateManyCustomerProfileInputEnvelope;
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutCustomerProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutCustomerProfileInput,
      UserUncheckedCreateWithoutCustomerProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCustomerProfileInput;
    upsert?: UserUpsertWithoutCustomerProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCustomerProfileInput,
        UserUpdateWithoutCustomerProfileInput
      >,
      UserUncheckedUpdateWithoutCustomerProfileInput
    >;
  };

  export type AddressUpdateManyWithoutCustomerProfileNestedInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerProfileInput,
          AddressUncheckedCreateWithoutCustomerProfileInput
        >
      | AddressCreateWithoutCustomerProfileInput[]
      | AddressUncheckedCreateWithoutCustomerProfileInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerProfileInput
      | AddressCreateOrConnectWithoutCustomerProfileInput[];
    upsert?:
      | AddressUpsertWithWhereUniqueWithoutCustomerProfileInput
      | AddressUpsertWithWhereUniqueWithoutCustomerProfileInput[];
    createMany?: AddressCreateManyCustomerProfileInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?:
      | AddressUpdateWithWhereUniqueWithoutCustomerProfileInput
      | AddressUpdateWithWhereUniqueWithoutCustomerProfileInput[];
    updateMany?:
      | AddressUpdateManyWithWhereWithoutCustomerProfileInput
      | AddressUpdateManyWithWhereWithoutCustomerProfileInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type AddressUncheckedUpdateManyWithoutCustomerProfileNestedInput = {
    create?:
      | XOR<
          AddressCreateWithoutCustomerProfileInput,
          AddressUncheckedCreateWithoutCustomerProfileInput
        >
      | AddressCreateWithoutCustomerProfileInput[]
      | AddressUncheckedCreateWithoutCustomerProfileInput[];
    connectOrCreate?:
      | AddressCreateOrConnectWithoutCustomerProfileInput
      | AddressCreateOrConnectWithoutCustomerProfileInput[];
    upsert?:
      | AddressUpsertWithWhereUniqueWithoutCustomerProfileInput
      | AddressUpsertWithWhereUniqueWithoutCustomerProfileInput[];
    createMany?: AddressCreateManyCustomerProfileInputEnvelope;
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[];
    update?:
      | AddressUpdateWithWhereUniqueWithoutCustomerProfileInput
      | AddressUpdateWithWhereUniqueWithoutCustomerProfileInput[];
    updateMany?:
      | AddressUpdateManyWithWhereWithoutCustomerProfileInput
      | AddressUpdateManyWithWhereWithoutCustomerProfileInput[];
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutVendorProfileInput = {
    create?: XOR<
      UserCreateWithoutVendorProfileInput,
      UserUncheckedCreateWithoutVendorProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVendorProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutVendorProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutVendorProfileInput,
      UserUncheckedCreateWithoutVendorProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutVendorProfileInput;
    upsert?: UserUpsertWithoutVendorProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutVendorProfileInput,
        UserUpdateWithoutVendorProfileInput
      >,
      UserUncheckedUpdateWithoutVendorProfileInput
    >;
  };

  export type UserCreateNestedOneWithoutDriverProfileInput = {
    create?: XOR<
      UserCreateWithoutDriverProfileInput,
      UserUncheckedCreateWithoutDriverProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDriverProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumDriverTierFieldUpdateOperationsInput = {
    set?: $Enums.DriverTier;
  };

  export type UserUpdateOneRequiredWithoutDriverProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutDriverProfileInput,
      UserUncheckedCreateWithoutDriverProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutDriverProfileInput;
    upsert?: UserUpsertWithoutDriverProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutDriverProfileInput,
        UserUpdateWithoutDriverProfileInput
      >,
      UserUncheckedUpdateWithoutDriverProfileInput
    >;
  };

  export type UserCreateNestedOneWithoutHostProfileInput = {
    create?: XOR<
      UserCreateWithoutHostProfileInput,
      UserUncheckedCreateWithoutHostProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutHostProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumHostTierFieldUpdateOperationsInput = {
    set?: $Enums.HostTier;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type UserUpdateOneRequiredWithoutHostProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutHostProfileInput,
      UserUncheckedCreateWithoutHostProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutHostProfileInput;
    upsert?: UserUpsertWithoutHostProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutHostProfileInput,
        UserUpdateWithoutHostProfileInput
      >,
      UserUncheckedUpdateWithoutHostProfileInput
    >;
  };

  export type UserCreateNestedOneWithoutAdvertiserProfileInput = {
    create?: XOR<
      UserCreateWithoutAdvertiserProfileInput,
      UserUncheckedCreateWithoutAdvertiserProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAdvertiserProfileInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutAdvertiserProfileNestedInput = {
    create?: XOR<
      UserCreateWithoutAdvertiserProfileInput,
      UserUncheckedCreateWithoutAdvertiserProfileInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAdvertiserProfileInput;
    upsert?: UserUpsertWithoutAdvertiserProfileInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAdvertiserProfileInput,
        UserUpdateWithoutAdvertiserProfileInput
      >,
      UserUncheckedUpdateWithoutAdvertiserProfileInput
    >;
  };

  export type CustomerProfileCreateNestedOneWithoutAddressesInput = {
    create?: XOR<
      CustomerProfileCreateWithoutAddressesInput,
      CustomerProfileUncheckedCreateWithoutAddressesInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutAddressesInput;
    connect?: CustomerProfileWhereUniqueInput;
  };

  export type CustomerProfileUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<
      CustomerProfileCreateWithoutAddressesInput,
      CustomerProfileUncheckedCreateWithoutAddressesInput
    >;
    connectOrCreate?: CustomerProfileCreateOrConnectWithoutAddressesInput;
    upsert?: CustomerProfileUpsertWithoutAddressesInput;
    connect?: CustomerProfileWhereUniqueInput;
    update?: XOR<
      XOR<
        CustomerProfileUpdateToOneWithWhereWithoutAddressesInput,
        CustomerProfileUpdateWithoutAddressesInput
      >,
      CustomerProfileUncheckedUpdateWithoutAddressesInput
    >;
  };

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput;
    upsert?: UserUpsertWithoutRefreshTokensInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRefreshTokensInput,
        UserUpdateWithoutRefreshTokensInput
      >,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
  };

  export type UserCreateNestedOneWithoutEmailVerificationTokensInput = {
    create?: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutEmailVerificationTokensNestedInput = {
    create?: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationTokensInput;
    upsert?: UserUpsertWithoutEmailVerificationTokensInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput,
        UserUpdateWithoutEmailVerificationTokensInput
      >,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
  };

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<
      UserCreateWithoutPasswordResetTokensInput,
      UserUncheckedCreateWithoutPasswordResetTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<
      UserCreateWithoutPasswordResetTokensInput,
      UserUncheckedCreateWithoutPasswordResetTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput;
    upsert?: UserUpsertWithoutPasswordResetTokensInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPasswordResetTokensInput,
        UserUpdateWithoutPasswordResetTokensInput
      >,
      UserUncheckedUpdateWithoutPasswordResetTokensInput
    >;
  };

  export type UserCreateNestedOneWithoutPhoneVerificationCodesInput = {
    create?: XOR<
      UserCreateWithoutPhoneVerificationCodesInput,
      UserUncheckedCreateWithoutPhoneVerificationCodesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationCodesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutPhoneVerificationCodesNestedInput = {
    create?: XOR<
      UserCreateWithoutPhoneVerificationCodesInput,
      UserUncheckedCreateWithoutPhoneVerificationCodesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPhoneVerificationCodesInput;
    upsert?: UserUpsertWithoutPhoneVerificationCodesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPhoneVerificationCodesInput,
        UserUpdateWithoutPhoneVerificationCodesInput
      >,
      UserUncheckedUpdateWithoutPhoneVerificationCodesInput
    >;
  };

  export type UserCreateNestedOneWithoutAdminAuditLogsInput = {
    create?: XOR<
      UserCreateWithoutAdminAuditLogsInput,
      UserUncheckedCreateWithoutAdminAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutTargetAuditLogsInput = {
    create?: XOR<
      UserCreateWithoutTargetAuditLogsInput,
      UserUncheckedCreateWithoutTargetAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTargetAuditLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutAdminAuditLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutAdminAuditLogsInput,
      UserUncheckedCreateWithoutAdminAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAdminAuditLogsInput;
    upsert?: UserUpsertWithoutAdminAuditLogsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAdminAuditLogsInput,
        UserUpdateWithoutAdminAuditLogsInput
      >,
      UserUncheckedUpdateWithoutAdminAuditLogsInput
    >;
  };

  export type UserUpdateOneWithoutTargetAuditLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutTargetAuditLogsInput,
      UserUncheckedCreateWithoutTargetAuditLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutTargetAuditLogsInput;
    upsert?: UserUpsertWithoutTargetAuditLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutTargetAuditLogsInput,
        UserUpdateWithoutTargetAuditLogsInput
      >,
      UserUncheckedUpdateWithoutTargetAuditLogsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>;
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>;
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumRoleNameWithAggregatesFilter<$PrismaModel>
      | $Enums.RoleName;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumRoleNameFilter<$PrismaModel>;
    _max?: NestedEnumRoleNameFilter<$PrismaModel>;
  };
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonNullableFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>
      >;

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubscriptionTier
      | EnumSubscriptionTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionTierFilter<$PrismaModel>
      | $Enums.SubscriptionTier;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumSubscriptionTierWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SubscriptionTier
      | EnumSubscriptionTierFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionTier[]
      | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel>
      | $Enums.SubscriptionTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedEnumDriverTierFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverTier | EnumDriverTierFieldRefInput<$PrismaModel>;
    in?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    not?: NestedEnumDriverTierFilter<$PrismaModel> | $Enums.DriverTier;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedEnumDriverTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverTier | EnumDriverTierFieldRefInput<$PrismaModel>;
    in?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.DriverTier[] | ListEnumDriverTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumDriverTierWithAggregatesFilter<$PrismaModel>
      | $Enums.DriverTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumDriverTierFilter<$PrismaModel>;
    _max?: NestedEnumDriverTierFilter<$PrismaModel>;
  };

  export type NestedEnumHostTierFilter<$PrismaModel = never> = {
    equals?: $Enums.HostTier | EnumHostTierFieldRefInput<$PrismaModel>;
    in?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    not?: NestedEnumHostTierFilter<$PrismaModel> | $Enums.HostTier;
  };

  export type NestedEnumHostTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HostTier | EnumHostTierFieldRefInput<$PrismaModel>;
    in?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    notIn?: $Enums.HostTier[] | ListEnumHostTierFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumHostTierWithAggregatesFilter<$PrismaModel>
      | $Enums.HostTier;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumHostTierFilter<$PrismaModel>;
    _max?: NestedEnumHostTierFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type UserRoleCreateWithoutUserInput = {
    id?: string;
    assignedAt?: Date | string;
    role: RoleCreateNestedOneWithoutUsersInput;
  };

  export type UserRoleUncheckedCreateWithoutUserInput = {
    id?: string;
    roleId: string;
    assignedAt?: Date | string;
  };

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    create: XOR<
      UserRoleCreateWithoutUserInput,
      UserRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type CustomerProfileCreateWithoutUserInput = {
    id?: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    addresses?: AddressCreateNestedManyWithoutCustomerProfileInput;
  };

  export type CustomerProfileUncheckedCreateWithoutUserInput = {
    id?: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    addresses?: AddressUncheckedCreateNestedManyWithoutCustomerProfileInput;
  };

  export type CustomerProfileCreateOrConnectWithoutUserInput = {
    where: CustomerProfileWhereUniqueInput;
    create: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type VendorProfileCreateWithoutUserInput = {
    id?: string;
    businessName: string;
    businessType: string;
    description?: string | null;
    logo?: string | null;
    website?: string | null;
    subscriptionTier?: $Enums.SubscriptionTier;
    commissionRate?: number;
    isVerified?: boolean;
    rating?: number | null;
    totalSales?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VendorProfileUncheckedCreateWithoutUserInput = {
    id?: string;
    businessName: string;
    businessType: string;
    description?: string | null;
    logo?: string | null;
    website?: string | null;
    subscriptionTier?: $Enums.SubscriptionTier;
    commissionRate?: number;
    isVerified?: boolean;
    rating?: number | null;
    totalSales?: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type VendorProfileCreateOrConnectWithoutUserInput = {
    where: VendorProfileWhereUniqueInput;
    create: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type DriverProfileCreateWithoutUserInput = {
    id?: string;
    licenseNumber: string;
    vehicleInfo: JsonNullValueInput | InputJsonValue;
    isOnline?: boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: number | null;
    totalRides?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.DriverTier;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DriverProfileUncheckedCreateWithoutUserInput = {
    id?: string;
    licenseNumber: string;
    vehicleInfo: JsonNullValueInput | InputJsonValue;
    isOnline?: boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: number | null;
    totalRides?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.DriverTier;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type DriverProfileCreateOrConnectWithoutUserInput = {
    where: DriverProfileWhereUniqueInput;
    create: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type HostProfileCreateWithoutUserInput = {
    id?: string;
    businessName?: string | null;
    description?: string | null;
    rating?: number | null;
    totalBookings?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.HostTier;
    responseRate?: number | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HostProfileUncheckedCreateWithoutUserInput = {
    id?: string;
    businessName?: string | null;
    description?: string | null;
    rating?: number | null;
    totalBookings?: number;
    isVerified?: boolean;
    subscriptionTier?: $Enums.HostTier;
    responseRate?: number | null;
    responseTime?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type HostProfileCreateOrConnectWithoutUserInput = {
    where: HostProfileWhereUniqueInput;
    create: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type AdvertiserProfileCreateWithoutUserInput = {
    id?: string;
    companyName: string;
    industry: string;
    website?: string | null;
    totalSpend?: number;
    isVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AdvertiserProfileUncheckedCreateWithoutUserInput = {
    id?: string;
    companyName: string;
    industry: string;
    website?: string | null;
    totalSpend?: number;
    isVerified?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AdvertiserProfileCreateOrConnectWithoutUserInput = {
    where: AdvertiserProfileWhereUniqueInput;
    create: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
  };

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    create: XOR<
      RefreshTokenCreateWithoutUserInput,
      RefreshTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type EmailVerificationTokenCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenCreateOrConnectWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    create: XOR<
      EmailVerificationTokenCreateWithoutUserInput,
      EmailVerificationTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenCreateManyUserInputEnvelope = {
    data:
      | EmailVerificationTokenCreateManyUserInput
      | EmailVerificationTokenCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput;
    create: XOR<
      PasswordResetTokenCreateWithoutUserInput,
      PasswordResetTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data:
      | PasswordResetTokenCreateManyUserInput
      | PasswordResetTokenCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type PhoneVerificationCodeCreateWithoutUserInput = {
    id?: string;
    code: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PhoneVerificationCodeUncheckedCreateWithoutUserInput = {
    id?: string;
    code: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PhoneVerificationCodeCreateOrConnectWithoutUserInput = {
    where: PhoneVerificationCodeWhereUniqueInput;
    create: XOR<
      PhoneVerificationCodeCreateWithoutUserInput,
      PhoneVerificationCodeUncheckedCreateWithoutUserInput
    >;
  };

  export type PhoneVerificationCodeCreateManyUserInputEnvelope = {
    data:
      | PhoneVerificationCodeCreateManyUserInput
      | PhoneVerificationCodeCreateManyUserInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutAdminUserInput = {
    id?: string;
    action: string;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    targetUser?: UserCreateNestedOneWithoutTargetAuditLogsInput;
  };

  export type AuditLogUncheckedCreateWithoutAdminUserInput = {
    id?: string;
    action: string;
    targetUserId?: string | null;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<
      AuditLogCreateWithoutAdminUserInput,
      AuditLogUncheckedCreateWithoutAdminUserInput
    >;
  };

  export type AuditLogCreateManyAdminUserInputEnvelope = {
    data: AuditLogCreateManyAdminUserInput | AuditLogCreateManyAdminUserInput[];
    skipDuplicates?: boolean;
  };

  export type AuditLogCreateWithoutTargetUserInput = {
    id?: string;
    action: string;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
    adminUser: UserCreateNestedOneWithoutAdminAuditLogsInput;
  };

  export type AuditLogUncheckedCreateWithoutTargetUserInput = {
    id?: string;
    action: string;
    adminUserId: string;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateOrConnectWithoutTargetUserInput = {
    where: AuditLogWhereUniqueInput;
    create: XOR<
      AuditLogCreateWithoutTargetUserInput,
      AuditLogUncheckedCreateWithoutTargetUserInput
    >;
  };

  export type AuditLogCreateManyTargetUserInputEnvelope = {
    data:
      | AuditLogCreateManyTargetUserInput
      | AuditLogCreateManyTargetUserInput[];
    skipDuplicates?: boolean;
  };

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    update: XOR<
      UserRoleUpdateWithoutUserInput,
      UserRoleUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      UserRoleCreateWithoutUserInput,
      UserRoleUncheckedCreateWithoutUserInput
    >;
  };

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput;
    data: XOR<
      UserRoleUpdateWithoutUserInput,
      UserRoleUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput;
    data: XOR<
      UserRoleUpdateManyMutationInput,
      UserRoleUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
    OR?: UserRoleScalarWhereInput[];
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[];
    id?: StringFilter<'UserRole'> | string;
    userId?: StringFilter<'UserRole'> | string;
    roleId?: StringFilter<'UserRole'> | string;
    assignedAt?: DateTimeFilter<'UserRole'> | Date | string;
  };

  export type CustomerProfileUpsertWithoutUserInput = {
    update: XOR<
      CustomerProfileUpdateWithoutUserInput,
      CustomerProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      CustomerProfileCreateWithoutUserInput,
      CustomerProfileUncheckedCreateWithoutUserInput
    >;
    where?: CustomerProfileWhereInput;
  };

  export type CustomerProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: CustomerProfileWhereInput;
    data: XOR<
      CustomerProfileUpdateWithoutUserInput,
      CustomerProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type CustomerProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    addresses?: AddressUpdateManyWithoutCustomerProfileNestedInput;
  };

  export type CustomerProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    addresses?: AddressUncheckedUpdateManyWithoutCustomerProfileNestedInput;
  };

  export type VendorProfileUpsertWithoutUserInput = {
    update: XOR<
      VendorProfileUpdateWithoutUserInput,
      VendorProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      VendorProfileCreateWithoutUserInput,
      VendorProfileUncheckedCreateWithoutUserInput
    >;
    where?: VendorProfileWhereInput;
  };

  export type VendorProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: VendorProfileWhereInput;
    data: XOR<
      VendorProfileUpdateWithoutUserInput,
      VendorProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type VendorProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type VendorProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: StringFieldUpdateOperationsInput | string;
    businessType?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    logo?: NullableStringFieldUpdateOperationsInput | string | null;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    subscriptionTier?:
      | EnumSubscriptionTierFieldUpdateOperationsInput
      | $Enums.SubscriptionTier;
    commissionRate?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalSales?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DriverProfileUpsertWithoutUserInput = {
    update: XOR<
      DriverProfileUpdateWithoutUserInput,
      DriverProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      DriverProfileCreateWithoutUserInput,
      DriverProfileUncheckedCreateWithoutUserInput
    >;
    where?: DriverProfileWhereInput;
  };

  export type DriverProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: DriverProfileWhereInput;
    data: XOR<
      DriverProfileUpdateWithoutUserInput,
      DriverProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type DriverProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type DriverProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    licenseNumber?: StringFieldUpdateOperationsInput | string;
    vehicleInfo?: JsonNullValueInput | InputJsonValue;
    isOnline?: BoolFieldUpdateOperationsInput | boolean;
    currentLocation?: NullableJsonNullValueInput | InputJsonValue;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalRides?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?:
      | EnumDriverTierFieldUpdateOperationsInput
      | $Enums.DriverTier;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HostProfileUpsertWithoutUserInput = {
    update: XOR<
      HostProfileUpdateWithoutUserInput,
      HostProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      HostProfileCreateWithoutUserInput,
      HostProfileUncheckedCreateWithoutUserInput
    >;
    where?: HostProfileWhereInput;
  };

  export type HostProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: HostProfileWhereInput;
    data: XOR<
      HostProfileUpdateWithoutUserInput,
      HostProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type HostProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type HostProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    businessName?: NullableStringFieldUpdateOperationsInput | string | null;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableFloatFieldUpdateOperationsInput | number | null;
    totalBookings?: IntFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    subscriptionTier?: EnumHostTierFieldUpdateOperationsInput | $Enums.HostTier;
    responseRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdvertiserProfileUpsertWithoutUserInput = {
    update: XOR<
      AdvertiserProfileUpdateWithoutUserInput,
      AdvertiserProfileUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AdvertiserProfileCreateWithoutUserInput,
      AdvertiserProfileUncheckedCreateWithoutUserInput
    >;
    where?: AdvertiserProfileWhereInput;
  };

  export type AdvertiserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AdvertiserProfileWhereInput;
    data: XOR<
      AdvertiserProfileUpdateWithoutUserInput,
      AdvertiserProfileUncheckedUpdateWithoutUserInput
    >;
  };

  export type AdvertiserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AdvertiserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    companyName?: StringFieldUpdateOperationsInput | string;
    industry?: StringFieldUpdateOperationsInput | string;
    website?: NullableStringFieldUpdateOperationsInput | string | null;
    totalSpend?: FloatFieldUpdateOperationsInput | number;
    isVerified?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    update: XOR<
      RefreshTokenUpdateWithoutUserInput,
      RefreshTokenUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      RefreshTokenCreateWithoutUserInput,
      RefreshTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    data: XOR<
      RefreshTokenUpdateWithoutUserInput,
      RefreshTokenUncheckedUpdateWithoutUserInput
    >;
  };

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput;
    data: XOR<
      RefreshTokenUpdateManyMutationInput,
      RefreshTokenUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
    OR?: RefreshTokenScalarWhereInput[];
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
    id?: StringFilter<'RefreshToken'> | string;
    token?: StringFilter<'RefreshToken'> | string;
    userId?: StringFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
  };

  export type EmailVerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    update: XOR<
      EmailVerificationTokenUpdateWithoutUserInput,
      EmailVerificationTokenUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      EmailVerificationTokenCreateWithoutUserInput,
      EmailVerificationTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailVerificationTokenWhereUniqueInput;
    data: XOR<
      EmailVerificationTokenUpdateWithoutUserInput,
      EmailVerificationTokenUncheckedUpdateWithoutUserInput
    >;
  };

  export type EmailVerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: EmailVerificationTokenScalarWhereInput;
    data: XOR<
      EmailVerificationTokenUpdateManyMutationInput,
      EmailVerificationTokenUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type EmailVerificationTokenScalarWhereInput = {
    AND?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
    OR?: EmailVerificationTokenScalarWhereInput[];
    NOT?:
      | EmailVerificationTokenScalarWhereInput
      | EmailVerificationTokenScalarWhereInput[];
    id?: StringFilter<'EmailVerificationToken'> | string;
    token?: StringFilter<'EmailVerificationToken'> | string;
    userId?: StringFilter<'EmailVerificationToken'> | string;
    expiresAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
    createdAt?: DateTimeFilter<'EmailVerificationToken'> | Date | string;
  };

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput;
    update: XOR<
      PasswordResetTokenUpdateWithoutUserInput,
      PasswordResetTokenUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PasswordResetTokenCreateWithoutUserInput,
      PasswordResetTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput;
    data: XOR<
      PasswordResetTokenUpdateWithoutUserInput,
      PasswordResetTokenUncheckedUpdateWithoutUserInput
    >;
  };

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput;
    data: XOR<
      PasswordResetTokenUpdateManyMutationInput,
      PasswordResetTokenUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PasswordResetTokenScalarWhereInput = {
    AND?:
      | PasswordResetTokenScalarWhereInput
      | PasswordResetTokenScalarWhereInput[];
    OR?: PasswordResetTokenScalarWhereInput[];
    NOT?:
      | PasswordResetTokenScalarWhereInput
      | PasswordResetTokenScalarWhereInput[];
    id?: StringFilter<'PasswordResetToken'> | string;
    token?: StringFilter<'PasswordResetToken'> | string;
    userId?: StringFilter<'PasswordResetToken'> | string;
    expiresAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
    createdAt?: DateTimeFilter<'PasswordResetToken'> | Date | string;
  };

  export type PhoneVerificationCodeUpsertWithWhereUniqueWithoutUserInput = {
    where: PhoneVerificationCodeWhereUniqueInput;
    update: XOR<
      PhoneVerificationCodeUpdateWithoutUserInput,
      PhoneVerificationCodeUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PhoneVerificationCodeCreateWithoutUserInput,
      PhoneVerificationCodeUncheckedCreateWithoutUserInput
    >;
  };

  export type PhoneVerificationCodeUpdateWithWhereUniqueWithoutUserInput = {
    where: PhoneVerificationCodeWhereUniqueInput;
    data: XOR<
      PhoneVerificationCodeUpdateWithoutUserInput,
      PhoneVerificationCodeUncheckedUpdateWithoutUserInput
    >;
  };

  export type PhoneVerificationCodeUpdateManyWithWhereWithoutUserInput = {
    where: PhoneVerificationCodeScalarWhereInput;
    data: XOR<
      PhoneVerificationCodeUpdateManyMutationInput,
      PhoneVerificationCodeUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PhoneVerificationCodeScalarWhereInput = {
    AND?:
      | PhoneVerificationCodeScalarWhereInput
      | PhoneVerificationCodeScalarWhereInput[];
    OR?: PhoneVerificationCodeScalarWhereInput[];
    NOT?:
      | PhoneVerificationCodeScalarWhereInput
      | PhoneVerificationCodeScalarWhereInput[];
    id?: StringFilter<'PhoneVerificationCode'> | string;
    code?: StringFilter<'PhoneVerificationCode'> | string;
    userId?: StringFilter<'PhoneVerificationCode'> | string;
    expiresAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
    createdAt?: DateTimeFilter<'PhoneVerificationCode'> | Date | string;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<
      AuditLogUpdateWithoutAdminUserInput,
      AuditLogUncheckedUpdateWithoutAdminUserInput
    >;
    create: XOR<
      AuditLogCreateWithoutAdminUserInput,
      AuditLogUncheckedCreateWithoutAdminUserInput
    >;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutAdminUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<
      AuditLogUpdateWithoutAdminUserInput,
      AuditLogUncheckedUpdateWithoutAdminUserInput
    >;
  };

  export type AuditLogUpdateManyWithWhereWithoutAdminUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyWithoutAdminUserInput
    >;
  };

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    OR?: AuditLogScalarWhereInput[];
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[];
    id?: StringFilter<'AuditLog'> | string;
    action?: StringFilter<'AuditLog'> | string;
    adminUserId?: StringFilter<'AuditLog'> | string;
    targetUserId?: StringNullableFilter<'AuditLog'> | string | null;
    details?: JsonFilter<'AuditLog'>;
    ipAddress?: StringNullableFilter<'AuditLog'> | string | null;
    userAgent?: StringNullableFilter<'AuditLog'> | string | null;
    createdAt?: DateTimeFilter<'AuditLog'> | Date | string;
  };

  export type AuditLogUpsertWithWhereUniqueWithoutTargetUserInput = {
    where: AuditLogWhereUniqueInput;
    update: XOR<
      AuditLogUpdateWithoutTargetUserInput,
      AuditLogUncheckedUpdateWithoutTargetUserInput
    >;
    create: XOR<
      AuditLogCreateWithoutTargetUserInput,
      AuditLogUncheckedCreateWithoutTargetUserInput
    >;
  };

  export type AuditLogUpdateWithWhereUniqueWithoutTargetUserInput = {
    where: AuditLogWhereUniqueInput;
    data: XOR<
      AuditLogUpdateWithoutTargetUserInput,
      AuditLogUncheckedUpdateWithoutTargetUserInput
    >;
  };

  export type AuditLogUpdateManyWithWhereWithoutTargetUserInput = {
    where: AuditLogScalarWhereInput;
    data: XOR<
      AuditLogUpdateManyMutationInput,
      AuditLogUncheckedUpdateManyWithoutTargetUserInput
    >;
  };

  export type PermissionCreateWithoutRolesInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
  };

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string;
    name: string;
    description?: string | null;
    createdAt?: Date | string;
  };

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput;
    create: XOR<
      PermissionCreateWithoutRolesInput,
      PermissionUncheckedCreateWithoutRolesInput
    >;
  };

  export type UserRoleCreateWithoutRoleInput = {
    id?: string;
    assignedAt?: Date | string;
    user: UserCreateNestedOneWithoutRolesInput;
  };

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    id?: string;
    userId: string;
    assignedAt?: Date | string;
  };

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    create: XOR<
      UserRoleCreateWithoutRoleInput,
      UserRoleUncheckedCreateWithoutRoleInput
    >;
  };

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[];
    skipDuplicates?: boolean;
  };

  export type PermissionUpsertWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput;
    update: XOR<
      PermissionUpdateWithoutRolesInput,
      PermissionUncheckedUpdateWithoutRolesInput
    >;
    create: XOR<
      PermissionCreateWithoutRolesInput,
      PermissionUncheckedCreateWithoutRolesInput
    >;
  };

  export type PermissionUpdateWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput;
    data: XOR<
      PermissionUpdateWithoutRolesInput,
      PermissionUncheckedUpdateWithoutRolesInput
    >;
  };

  export type PermissionUpdateManyWithWhereWithoutRolesInput = {
    where: PermissionScalarWhereInput;
    data: XOR<
      PermissionUpdateManyMutationInput,
      PermissionUncheckedUpdateManyWithoutRolesInput
    >;
  };

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[];
    OR?: PermissionScalarWhereInput[];
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[];
    id?: StringFilter<'Permission'> | string;
    name?: StringFilter<'Permission'> | string;
    description?: StringNullableFilter<'Permission'> | string | null;
    createdAt?: DateTimeFilter<'Permission'> | Date | string;
  };

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    update: XOR<
      UserRoleUpdateWithoutRoleInput,
      UserRoleUncheckedUpdateWithoutRoleInput
    >;
    create: XOR<
      UserRoleCreateWithoutRoleInput,
      UserRoleUncheckedCreateWithoutRoleInput
    >;
  };

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput;
    data: XOR<
      UserRoleUpdateWithoutRoleInput,
      UserRoleUncheckedUpdateWithoutRoleInput
    >;
  };

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput;
    data: XOR<
      UserRoleUpdateManyMutationInput,
      UserRoleUncheckedUpdateManyWithoutRoleInput
    >;
  };

  export type RoleCreateWithoutPermissionsInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserRoleCreateNestedManyWithoutRoleInput;
  };

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput;
  };

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutPermissionsInput,
      RoleUncheckedCreateWithoutPermissionsInput
    >;
  };

  export type RoleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: RoleWhereUniqueInput;
    update: XOR<
      RoleUpdateWithoutPermissionsInput,
      RoleUncheckedUpdateWithoutPermissionsInput
    >;
    create: XOR<
      RoleCreateWithoutPermissionsInput,
      RoleUncheckedCreateWithoutPermissionsInput
    >;
  };

  export type RoleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: RoleWhereUniqueInput;
    data: XOR<
      RoleUpdateWithoutPermissionsInput,
      RoleUncheckedUpdateWithoutPermissionsInput
    >;
  };

  export type RoleUpdateManyWithWhereWithoutPermissionsInput = {
    where: RoleScalarWhereInput;
    data: XOR<
      RoleUpdateManyMutationInput,
      RoleUncheckedUpdateManyWithoutPermissionsInput
    >;
  };

  export type RoleScalarWhereInput = {
    AND?: RoleScalarWhereInput | RoleScalarWhereInput[];
    OR?: RoleScalarWhereInput[];
    NOT?: RoleScalarWhereInput | RoleScalarWhereInput[];
    id?: StringFilter<'Role'> | string;
    name?: EnumRoleNameFilter<'Role'> | $Enums.RoleName;
    createdAt?: DateTimeFilter<'Role'> | Date | string;
    updatedAt?: DateTimeFilter<'Role'> | Date | string;
  };

  export type UserCreateWithoutRolesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRolesInput,
      UserUncheckedCreateWithoutRolesInput
    >;
  };

  export type RoleCreateWithoutUsersInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: PermissionCreateNestedManyWithoutRolesInput;
  };

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string;
    name: $Enums.RoleName;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput;
  };

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput;
    create: XOR<
      RoleCreateWithoutUsersInput,
      RoleUncheckedCreateWithoutUsersInput
    >;
  };

  export type UserUpsertWithoutRolesInput = {
    update: XOR<
      UserUpdateWithoutRolesInput,
      UserUncheckedUpdateWithoutRolesInput
    >;
    create: XOR<
      UserCreateWithoutRolesInput,
      UserUncheckedCreateWithoutRolesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRolesInput,
      UserUncheckedUpdateWithoutRolesInput
    >;
  };

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<
      RoleUpdateWithoutUsersInput,
      RoleUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      RoleCreateWithoutUsersInput,
      RoleUncheckedCreateWithoutUsersInput
    >;
    where?: RoleWhereInput;
  };

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput;
    data: XOR<
      RoleUpdateWithoutUsersInput,
      RoleUncheckedUpdateWithoutUsersInput
    >;
  };

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: PermissionUpdateManyWithoutRolesNestedInput;
  };

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput;
  };

  export type UserCreateWithoutCustomerProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutCustomerProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutCustomerProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCustomerProfileInput,
      UserUncheckedCreateWithoutCustomerProfileInput
    >;
  };

  export type AddressCreateWithoutCustomerProfileInput = {
    id?: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUncheckedCreateWithoutCustomerProfileInput = {
    id?: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressCreateOrConnectWithoutCustomerProfileInput = {
    where: AddressWhereUniqueInput;
    create: XOR<
      AddressCreateWithoutCustomerProfileInput,
      AddressUncheckedCreateWithoutCustomerProfileInput
    >;
  };

  export type AddressCreateManyCustomerProfileInputEnvelope = {
    data:
      | AddressCreateManyCustomerProfileInput
      | AddressCreateManyCustomerProfileInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithoutCustomerProfileInput = {
    update: XOR<
      UserUpdateWithoutCustomerProfileInput,
      UserUncheckedUpdateWithoutCustomerProfileInput
    >;
    create: XOR<
      UserCreateWithoutCustomerProfileInput,
      UserUncheckedCreateWithoutCustomerProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCustomerProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCustomerProfileInput,
      UserUncheckedUpdateWithoutCustomerProfileInput
    >;
  };

  export type UserUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type AddressUpsertWithWhereUniqueWithoutCustomerProfileInput = {
    where: AddressWhereUniqueInput;
    update: XOR<
      AddressUpdateWithoutCustomerProfileInput,
      AddressUncheckedUpdateWithoutCustomerProfileInput
    >;
    create: XOR<
      AddressCreateWithoutCustomerProfileInput,
      AddressUncheckedCreateWithoutCustomerProfileInput
    >;
  };

  export type AddressUpdateWithWhereUniqueWithoutCustomerProfileInput = {
    where: AddressWhereUniqueInput;
    data: XOR<
      AddressUpdateWithoutCustomerProfileInput,
      AddressUncheckedUpdateWithoutCustomerProfileInput
    >;
  };

  export type AddressUpdateManyWithWhereWithoutCustomerProfileInput = {
    where: AddressScalarWhereInput;
    data: XOR<
      AddressUpdateManyMutationInput,
      AddressUncheckedUpdateManyWithoutCustomerProfileInput
    >;
  };

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[];
    OR?: AddressScalarWhereInput[];
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[];
    id?: StringFilter<'Address'> | string;
    customerProfileId?: StringFilter<'Address'> | string;
    label?: StringFilter<'Address'> | string;
    address?: StringFilter<'Address'> | string;
    city?: StringFilter<'Address'> | string;
    country?: StringFilter<'Address'> | string;
    isDefault?: BoolFilter<'Address'> | boolean;
    createdAt?: DateTimeFilter<'Address'> | Date | string;
    updatedAt?: DateTimeFilter<'Address'> | Date | string;
  };

  export type UserCreateWithoutVendorProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutVendorProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutVendorProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutVendorProfileInput,
      UserUncheckedCreateWithoutVendorProfileInput
    >;
  };

  export type UserUpsertWithoutVendorProfileInput = {
    update: XOR<
      UserUpdateWithoutVendorProfileInput,
      UserUncheckedUpdateWithoutVendorProfileInput
    >;
    create: XOR<
      UserCreateWithoutVendorProfileInput,
      UserUncheckedCreateWithoutVendorProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutVendorProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutVendorProfileInput,
      UserUncheckedUpdateWithoutVendorProfileInput
    >;
  };

  export type UserUpdateWithoutVendorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutVendorProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutDriverProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutDriverProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutDriverProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutDriverProfileInput,
      UserUncheckedCreateWithoutDriverProfileInput
    >;
  };

  export type UserUpsertWithoutDriverProfileInput = {
    update: XOR<
      UserUpdateWithoutDriverProfileInput,
      UserUncheckedUpdateWithoutDriverProfileInput
    >;
    create: XOR<
      UserCreateWithoutDriverProfileInput,
      UserUncheckedCreateWithoutDriverProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutDriverProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutDriverProfileInput,
      UserUncheckedUpdateWithoutDriverProfileInput
    >;
  };

  export type UserUpdateWithoutDriverProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutDriverProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutHostProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutHostProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutHostProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutHostProfileInput,
      UserUncheckedCreateWithoutHostProfileInput
    >;
  };

  export type UserUpsertWithoutHostProfileInput = {
    update: XOR<
      UserUpdateWithoutHostProfileInput,
      UserUncheckedUpdateWithoutHostProfileInput
    >;
    create: XOR<
      UserCreateWithoutHostProfileInput,
      UserUncheckedCreateWithoutHostProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutHostProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutHostProfileInput,
      UserUncheckedUpdateWithoutHostProfileInput
    >;
  };

  export type UserUpdateWithoutHostProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutHostProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutAdvertiserProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutAdvertiserProfileInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutAdvertiserProfileInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAdvertiserProfileInput,
      UserUncheckedCreateWithoutAdvertiserProfileInput
    >;
  };

  export type UserUpsertWithoutAdvertiserProfileInput = {
    update: XOR<
      UserUpdateWithoutAdvertiserProfileInput,
      UserUncheckedUpdateWithoutAdvertiserProfileInput
    >;
    create: XOR<
      UserCreateWithoutAdvertiserProfileInput,
      UserUncheckedCreateWithoutAdvertiserProfileInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAdvertiserProfileInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAdvertiserProfileInput,
      UserUncheckedUpdateWithoutAdvertiserProfileInput
    >;
  };

  export type UserUpdateWithoutAdvertiserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAdvertiserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type CustomerProfileCreateWithoutAddressesInput = {
    id?: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutCustomerProfileInput;
  };

  export type CustomerProfileUncheckedCreateWithoutAddressesInput = {
    id?: string;
    userId: string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CustomerProfileCreateOrConnectWithoutAddressesInput = {
    where: CustomerProfileWhereUniqueInput;
    create: XOR<
      CustomerProfileCreateWithoutAddressesInput,
      CustomerProfileUncheckedCreateWithoutAddressesInput
    >;
  };

  export type CustomerProfileUpsertWithoutAddressesInput = {
    update: XOR<
      CustomerProfileUpdateWithoutAddressesInput,
      CustomerProfileUncheckedUpdateWithoutAddressesInput
    >;
    create: XOR<
      CustomerProfileCreateWithoutAddressesInput,
      CustomerProfileUncheckedCreateWithoutAddressesInput
    >;
    where?: CustomerProfileWhereInput;
  };

  export type CustomerProfileUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerProfileWhereInput;
    data: XOR<
      CustomerProfileUpdateWithoutAddressesInput,
      CustomerProfileUncheckedUpdateWithoutAddressesInput
    >;
  };

  export type CustomerProfileUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutCustomerProfileNestedInput;
  };

  export type CustomerProfileUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    preferences?: NullableJsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
  };

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<
      UserUpdateWithoutRefreshTokensInput,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
    create: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRefreshTokensInput,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
  };

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutEmailVerificationTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutEmailVerificationTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutEmailVerificationTokensInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
  };

  export type UserUpsertWithoutEmailVerificationTokensInput = {
    update: XOR<
      UserUpdateWithoutEmailVerificationTokensInput,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
    create: XOR<
      UserCreateWithoutEmailVerificationTokensInput,
      UserUncheckedCreateWithoutEmailVerificationTokensInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutEmailVerificationTokensInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutEmailVerificationTokensInput,
      UserUncheckedUpdateWithoutEmailVerificationTokensInput
    >;
  };

  export type UserUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutEmailVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPasswordResetTokensInput,
      UserUncheckedCreateWithoutPasswordResetTokensInput
    >;
  };

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<
      UserUpdateWithoutPasswordResetTokensInput,
      UserUncheckedUpdateWithoutPasswordResetTokensInput
    >;
    create: XOR<
      UserCreateWithoutPasswordResetTokensInput,
      UserUncheckedCreateWithoutPasswordResetTokensInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPasswordResetTokensInput,
      UserUncheckedUpdateWithoutPasswordResetTokensInput
    >;
  };

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutPhoneVerificationCodesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutPhoneVerificationCodesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutPhoneVerificationCodesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPhoneVerificationCodesInput,
      UserUncheckedCreateWithoutPhoneVerificationCodesInput
    >;
  };

  export type UserUpsertWithoutPhoneVerificationCodesInput = {
    update: XOR<
      UserUpdateWithoutPhoneVerificationCodesInput,
      UserUncheckedUpdateWithoutPhoneVerificationCodesInput
    >;
    create: XOR<
      UserCreateWithoutPhoneVerificationCodesInput,
      UserUncheckedCreateWithoutPhoneVerificationCodesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPhoneVerificationCodesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPhoneVerificationCodesInput,
      UserUncheckedUpdateWithoutPhoneVerificationCodesInput
    >;
  };

  export type UserUpdateWithoutPhoneVerificationCodesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutPhoneVerificationCodesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserCreateWithoutAdminAuditLogsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    targetAuditLogs?: AuditLogCreateNestedManyWithoutTargetUserInput;
  };

  export type UserUncheckedCreateWithoutAdminAuditLogsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    targetAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutTargetUserInput;
  };

  export type UserCreateOrConnectWithoutAdminAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAdminAuditLogsInput,
      UserUncheckedCreateWithoutAdminAuditLogsInput
    >;
  };

  export type UserCreateWithoutTargetAuditLogsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogCreateNestedManyWithoutAdminUserInput;
  };

  export type UserUncheckedCreateWithoutTargetAuditLogsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    passwordHash: string;
    firstName: string;
    lastName: string;
    avatar?: string | null;
    isEmailVerified?: boolean;
    isPhoneVerified?: boolean;
    isActive?: boolean;
    lastLoginAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    activeRole?: $Enums.RoleName;
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput;
    customerProfile?: CustomerProfileUncheckedCreateNestedOneWithoutUserInput;
    vendorProfile?: VendorProfileUncheckedCreateNestedOneWithoutUserInput;
    driverProfile?: DriverProfileUncheckedCreateNestedOneWithoutUserInput;
    hostProfile?: HostProfileUncheckedCreateNestedOneWithoutUserInput;
    advertiserProfile?: AdvertiserProfileUncheckedCreateNestedOneWithoutUserInput;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedCreateNestedManyWithoutUserInput;
    passwordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedCreateNestedManyWithoutUserInput;
    adminAuditLogs?: AuditLogUncheckedCreateNestedManyWithoutAdminUserInput;
  };

  export type UserCreateOrConnectWithoutTargetAuditLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutTargetAuditLogsInput,
      UserUncheckedCreateWithoutTargetAuditLogsInput
    >;
  };

  export type UserUpsertWithoutAdminAuditLogsInput = {
    update: XOR<
      UserUpdateWithoutAdminAuditLogsInput,
      UserUncheckedUpdateWithoutAdminAuditLogsInput
    >;
    create: XOR<
      UserCreateWithoutAdminAuditLogsInput,
      UserUncheckedCreateWithoutAdminAuditLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAdminAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAdminAuditLogsInput,
      UserUncheckedUpdateWithoutAdminAuditLogsInput
    >;
  };

  export type UserUpdateWithoutAdminAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    targetAuditLogs?: AuditLogUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutAdminAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    targetAuditLogs?: AuditLogUncheckedUpdateManyWithoutTargetUserNestedInput;
  };

  export type UserUpsertWithoutTargetAuditLogsInput = {
    update: XOR<
      UserUpdateWithoutTargetAuditLogsInput,
      UserUncheckedUpdateWithoutTargetAuditLogsInput
    >;
    create: XOR<
      UserCreateWithoutTargetAuditLogsInput,
      UserUncheckedCreateWithoutTargetAuditLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutTargetAuditLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutTargetAuditLogsInput,
      UserUncheckedUpdateWithoutTargetAuditLogsInput
    >;
  };

  export type UserUpdateWithoutTargetAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUpdateManyWithoutAdminUserNestedInput;
  };

  export type UserUncheckedUpdateWithoutTargetAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    firstName?: StringFieldUpdateOperationsInput | string;
    lastName?: StringFieldUpdateOperationsInput | string;
    avatar?: NullableStringFieldUpdateOperationsInput | string | null;
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean;
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    lastLoginAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    activeRole?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput;
    customerProfile?: CustomerProfileUncheckedUpdateOneWithoutUserNestedInput;
    vendorProfile?: VendorProfileUncheckedUpdateOneWithoutUserNestedInput;
    driverProfile?: DriverProfileUncheckedUpdateOneWithoutUserNestedInput;
    hostProfile?: HostProfileUncheckedUpdateOneWithoutUserNestedInput;
    advertiserProfile?: AdvertiserProfileUncheckedUpdateOneWithoutUserNestedInput;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    emailVerificationTokens?: EmailVerificationTokenUncheckedUpdateManyWithoutUserNestedInput;
    passwordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput;
    phoneVerificationCodes?: PhoneVerificationCodeUncheckedUpdateManyWithoutUserNestedInput;
    adminAuditLogs?: AuditLogUncheckedUpdateManyWithoutAdminUserNestedInput;
  };

  export type UserRoleCreateManyUserInput = {
    id?: string;
    roleId: string;
    assignedAt?: Date | string;
  };

  export type RefreshTokenCreateManyUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type EmailVerificationTokenCreateManyUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type PhoneVerificationCodeCreateManyUserInput = {
    id?: string;
    code: string;
    expiresAt: Date | string;
    createdAt?: Date | string;
  };

  export type AuditLogCreateManyAdminUserInput = {
    id?: string;
    action: string;
    targetUserId?: string | null;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type AuditLogCreateManyTargetUserInput = {
    id?: string;
    action: string;
    adminUserId: string;
    details: JsonNullValueInput | InputJsonValue;
    ipAddress?: string | null;
    userAgent?: string | null;
    createdAt?: Date | string;
  };

  export type UserRoleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput;
  };

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    roleId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type EmailVerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PhoneVerificationCodeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    code?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    targetUser?: UserUpdateOneWithoutTargetAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutAdminUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    targetUserId?: NullableStringFieldUpdateOperationsInput | string | null;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    adminUser?: UserUpdateOneRequiredWithoutAdminAuditLogsNestedInput;
  };

  export type AuditLogUncheckedUpdateWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    adminUserId?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AuditLogUncheckedUpdateManyWithoutTargetUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    action?: StringFieldUpdateOperationsInput | string;
    adminUserId?: StringFieldUpdateOperationsInput | string;
    details?: JsonNullValueInput | InputJsonValue;
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null;
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleCreateManyRoleInput = {
    id?: string;
    userId: string;
    assignedAt?: Date | string;
  };

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PermissionUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutRolesNestedInput;
  };

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserRoleUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput;
  };

  export type RoleUncheckedUpdateManyWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressCreateManyCustomerProfileInput = {
    id?: string;
    label: string;
    address: string;
    city: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AddressUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AddressUncheckedUpdateManyWithoutCustomerProfileInput = {
    id?: StringFieldUpdateOperationsInput | string;
    label?: StringFieldUpdateOperationsInput | string;
    address?: StringFieldUpdateOperationsInput | string;
    city?: StringFieldUpdateOperationsInput | string;
    country?: StringFieldUpdateOperationsInput | string;
    isDefault?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Aliases for legacy arg types
   */
  /**
   * @deprecated Use UserCountOutputTypeDefaultArgs instead
   */
  export type UserCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = UserCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RoleCountOutputTypeDefaultArgs instead
   */
  export type RoleCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = RoleCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PermissionCountOutputTypeDefaultArgs instead
   */
  export type PermissionCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = PermissionCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CustomerProfileCountOutputTypeDefaultArgs instead
   */
  export type CustomerProfileCountOutputTypeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CustomerProfileCountOutputTypeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UserDefaultArgs instead
   */
  export type UserArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = UserDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RoleDefaultArgs instead
   */
  export type RoleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = RoleDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PermissionDefaultArgs instead
   */
  export type PermissionArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = PermissionDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use UserRoleDefaultArgs instead
   */
  export type UserRoleArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = UserRoleDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use CustomerProfileDefaultArgs instead
   */
  export type CustomerProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = CustomerProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use VendorProfileDefaultArgs instead
   */
  export type VendorProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = VendorProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use DriverProfileDefaultArgs instead
   */
  export type DriverProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = DriverProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use HostProfileDefaultArgs instead
   */
  export type HostProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = HostProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AdvertiserProfileDefaultArgs instead
   */
  export type AdvertiserProfileArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = AdvertiserProfileDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AddressDefaultArgs instead
   */
  export type AddressArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = AddressDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use RefreshTokenDefaultArgs instead
   */
  export type RefreshTokenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = RefreshTokenDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use EmailVerificationTokenDefaultArgs instead
   */
  export type EmailVerificationTokenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = EmailVerificationTokenDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PasswordResetTokenDefaultArgs instead
   */
  export type PasswordResetTokenArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = PasswordResetTokenDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use PhoneVerificationCodeDefaultArgs instead
   */
  export type PhoneVerificationCodeArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = PhoneVerificationCodeDefaultArgs<ExtArgs>;
  /**
   * @deprecated Use AuditLogDefaultArgs instead
   */
  export type AuditLogArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = AuditLogDefaultArgs<ExtArgs>;

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
